#! /Applications/Nuke13.0v3/Nuke13.0v3.app/Contents/MacOS/libnuke-13.0.3.dylib -nx
version 13.0 v3
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="25" w="3008" h="1562" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="2345" stretch="1"/>
            <splitter orientation="2">
                <split size="905"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="637"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <splitter orientation="2">
                <split size="771"/>
                <dock id="" activePageId="Properties.1">
                    <page id="Properties.1"/>
                    <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                </dock>
                <split size="771"/>
                <dock id="" activePageId="uk.co.thefoundry.scripteditor.1">
                    <page id="uk.co.thefoundry.scripteditor.1"/>
                </dock>
            </splitter>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /Users/afry/GitHub/ACES_ODT_Candidates/ACES_ODT_Candidates_LUT_Bake.nk
 project_directory "\[python \{nuke.script_directory()\}]"
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 OCIO_config custom
 customOCIOConfigPath /Users/afry/Documents/GitHub/OpenColorIO-Configs/aces_1.2/config.ocio
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0x388e8e00
 label "Candidate A\nPer Channel"
 note_font_size 42
 xpos -29
 ypos 138
 bdwidth 364
 bdheight 370
}
BackdropNode {
 inputs 0
 name BackdropNode2
 tile_color 0x388e8e00
 label "Candidate B\nOpen DRT"
 note_font_size 42
 xpos 395
 ypos 139
 bdwidth 366
 bdheight 369
}
BackdropNode {
 inputs 0
 name BackdropNode3
 tile_color 0x388e8e00
 label "Candidate C\nDRT ZCAM IzMh"
 note_font_size 42
 xpos 832
 ypos 137
 bdwidth 365
 bdheight 475
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/Working/ODT_VWG_TestClips/TheLegoMovie_OT_VWG_zmk17_020_aces.0287.exr
 format "2000 824 0 0 2000 824 1 kragle(Overscan)"
 origset true
 raw true
 name Read1
 xpos 92
 ypos -142
}
Constant {
 inputs 0
 channels rgb
 color 1
 format "1024 1024 0 0 1024 1024 1 square_1K"
 name Constant1
 xpos 200
 ypos -143
}
Ramp {
 replace true
 p0 {0 0}
 p1 {1023 0}
 name Ramp1
 xpos 200
 ypos -57
}
Colorspace {
 inputs 0
 colorspace_out sRGB
 primary_out DCI-P3
 name Colorspace1
 xpos -304
 ypos 428
}
CMSTestPattern {
 inputs 0
 cube_size 65
 name CMSTestPattern1
 xpos -19
 ypos -143
}
set N1aee9800 [stack 0]
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_log?(r-B)/A:pow(2,r*17.52-9.72)
 expr1 g<=cut_log?(g-B)/A:pow(2,g*17.52-9.72)
 expr2 b<=cut_log?(b-B)/A:pow(2,b*17.52-9.72)
 channel3 none
 name log2lin
 label ACEScct
 xpos -19
 ypos -28
}
Dot {
 name Dot1
 xpos 15
 ypos 24
}
set N1aee8c00 [stack 0]
Dot {
 name Dot4
 xpos 890
 ypos 245
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 name ColorMatrix12
 label "APS4 to XYZ"
 xpos 856
 ypos 263
}
Colorspace {
 colorspace_in CIE-XYZ
 illuminant_out ACES
 primary_out ACES
 name Colorspace4
 label "XYZ to AP0"
 xpos 856
 ypos 295
}
Reformat {
 type scale
 scale 0.1428571429
 filter impulse
 name Reformat1
 label "scale down 1/7 for speed"
 xpos 856
 ypos 347
}
set N45dcc800 [stack 0]
Group {
 name DRT_ZCAM_IzMh_v12_Blink3
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\nBodged XYZ_to_LMS_ZCAM matrix\nMM tonecurve"
 note_font "Bitstream Vera Sans"
 xpos 1093
 ypos 394
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 addUserKnob {4 cat_type l "CAT Type" t "the chromatic adaptation transform to use for converting between white points" M {None "XYZ Scaling" Bradford CAT02 Zhai2018 ""}}
 cat_type Zhai2018
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {6 apply_ssts l "apply SSTS" t "toggle the SingleStageToneScale transform" +STARTLINE}
 apply_ssts true
 addUserKnob {41 DRT_ZCAM_v12_Kernel_mmTonescaleMode l mmTonescaleMode T BlinkScript1.DRT_ZCAM_v12_Kernel_mmTonescaleMode}
 addUserKnob {13 ssts_luminance l "SSTS luminance" t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 1000}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {6 apply_highlight_desat l "apply highlight desat" t "toggle de-saturating the highlights above SSTS mid luminance based on how much the SSTS has compressed them" +STARTLINE}
 apply_highlight_desat true
 addUserKnob {7 desat_highlights l "desat highlights" t "the amount of desaturation applied to the highlights" R 0 5}
 desat_highlights 3.5
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 apply_gamut_compression l "apply gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l primaries t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI ""}}
 primaries_limit P3-D65
 addUserKnob {6 discount_illuminant l "discount illuminant (Zhai2018 only)" t "disable the degree of adaptation model for the Zhai2018 CAT\nthis is only effective if the limiting primaries do not use a D65 white point" -STARTLINE}
 discount_illuminant true
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.5
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "gamut cusp (0) to SSTS mid (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "the distance from the achromatic axis of the focal point of the compression where 0.0 is at the achromatic axis and 1.0 the distance of the gamut cusp at the given hue but on the opposite side of the achomatic axis" R 0 2}
 focus_distance 0.5
 addUserKnob {26 focus_depth_label l " " -STARTLINE T "achromatic (0) to cusp opposite (1)"}
 addUserKnob {13 compression_params l compression t "the threshold, limit and power parameters for the PowerP compression function\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.2 1.2}
 addUserKnob {26 compression_params_label l " " -STARTLINE T "threshold / limit / power"}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {3 solve_precision l "solve precision" t "the number of iterations used for finding the gamut boundary using the interval bisection method"}
 solve_precision 10
 addUserKnob {3 inverse_solver_iterations l "inverse solver iterations" t "the number of iterations used for finding the original J & M values when applying the inverse gamut compression"}
 inverse_solver_iterations 10
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 ""}}
 encoding_out ST2084
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
}
 ColorMatrix {
  inputs 0
  matrix {
      {0.368792 0.531205 0.103642}
      {-0.193458 1.03225 0.131287}
      {-0.0348077 0.283972 0.671427}
    }
  name preMatrix
  xpos -786
  ypos -227
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -294
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/ACES_ODT_Candidates/blink/ZCAM_DRT_v012.blink
  recompileCount 419
  ProgramGroup 1
  KernelDescription "2 \"DRT_ZCAM_v12_Kernel\" iterate pixelWise fffa4edb9a297aff0d39c854057b4a543a4c2c5ce2c43bc6e9e86d9f0226d5fa 2 \"src\" Read Point \"dst\" Write Point 42 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"discountIlluminant\" Bool 1 AA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"applySsts\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyHighlightDesat\" Bool 1 AA== \"desatHighlights\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"boundarySolvePrecision\" Int 1 AAAAAA== \"inverseSolverIterations\" Int 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"invert\" Bool 1 AA== \"XYZ_to_LMS_ZCAM\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"zcam_rho\" Float 1 AAAAAA== \"mmTonescaleMode\" Bool 1 AA== \"Lp\" Float 1 AAAAAA== \"su\" Float 1 AAAAAA== \"c0\" Float 1 AAAAAA== \"cs\" Float 1 AAAAAA== \"c1\" Float 1 AAAAAA== \"p\" Float 1 AAAAAA== \"w1\" Float 1 AAAAAA== \"s1\" Float 1 AAAAAA== \"ex\" Float 1 AAAAAA== \"eb\" Float 1 AAAAAA== \"e0\" Float 1 AAAAAA== \"s0\" Float 1 AAAAAA== \"fl\" Float 1 AAAAAA== \"dch\" Float 1 AAAAAA== \"sat\" Float 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== 42 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"catType\" 1 1 \"discountIlluminant\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"applySsts\" 1 1 \"sstsLuminance\" 3 1 \"applyHighlightDesat\" 1 1 \"desatHighlights\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 3 1 \"smoothCusps\" 1 1 \"boundarySolvePrecision\" 1 1 \"inverseSolverIterations\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"invert\" 1 1 \"XYZ_to_LMS_ZCAM\" 9 1 \"zcam_rho\" 1 1 \"mmTonescaleMode\" 1 1 \"Lp\" 1 1 \"su\" 1 1 \"c0\" 1 1 \"cs\" 1 1 \"c1\" 1 1 \"p\" 1 1 \"w1\" 1 1 \"s1\" 1 1 \"ex\" 1 1 \"eb\" 1 1 \"e0\" 1 1 \"s0\" 1 1 \"fl\" 1 1 \"dch\" 1 1 \"sat\" 1 1 \"mmScaleFactor\" 1 1 70 \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA== \"zcam_L_A\" Float 1 1 AAAAAA== \"zcam_F_b\" Float 1 1 AAAAAA== \"zcam_F_L\" Float 1 1 AAAAAA== \"zcam_cb\" Float 1 1 AAAAAA== \"zcam_cg\" Float 1 1 AAAAAA== \"zcam_c1\" Float 1 1 AAAAAA== \"zcam_c2\" Float 1 1 AAAAAA== \"zcam_c3\" Float 1 1 AAAAAA== \"zcam_eta\" Float 1 1 AAAAAA== \"zcam_luminance_shift\" Float 1 1 AAAAAA== \"zcam_viewing_conditions_coeff\" Float 1 1 AAAAAA== \"cat_adaptDegree\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"ssts_min_stop_sdr\" Float 1 1 AAAAAA== \"ssts_max_stop_sdr\" Float 1 1 AAAAAA== \"ssts_min_stop_rrt\" Float 1 1 AAAAAA== \"ssts_max_stop_rrt\" Float 1 1 AAAAAA== \"ssts_min_lum_sdr\" Float 1 1 AAAAAA== \"ssts_max_lum_sdr\" Float 1 1 AAAAAA== \"ssts_min_lum_rrt\" Float 1 1 AAAAAA== \"ssts_max_lum_rrt\" Float 1 1 AAAAAA== \"ssts_n_knots_low\" Int 1 1 AAAAAA== \"ssts_n_knots_high\" Int 1 1 AAAAAA== \"ssts_m1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_minTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_maxTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsLow\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsHigh\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_min_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_mid_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_max_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_knotIncLow\" Float 1 1 AAAAAA== \"ssts_knotIncHigh\" Float 1 1 AAAAAA== \"ssts_pctLow\" Float 1 1 AAAAAA== \"ssts_pctHigh\" Float 1 1 AAAAAA== \"ssts_coefsLow\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_coefsHigh\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_expShift\" Float 1 1 AAAAAA== \"ssts_paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"limitMmax\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"focusDistanceClamped\" Float 1 1 AAAAAA=="
  kernelSource "\nkernel DRT_ZCAM_v12_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    //\n    // ZCAM Paramters\n    //\n\n    // Chomatic Adaptation Transform to Use\n    // 0: None\n    // 1: XYZ Scaling\n    // 2: Bradford\n    // 3: CAT02\n    // 4: Zhai2018 (two-step)\n    int catType;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    //\n    // SSTS Parameters\n    //\n\n    // Toggle SSTS Tone Mapping\n    bool applySsts;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle Highlight De-Saturation\n    bool applyHighlightDesat;\n\n    // Scale the De-Saturation Applied to the Highlights\n    float desatHighlights;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // the distance of the compression focal point\n    // from the achromatic axis\n    // normalised to the distance of the gamut cusp\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / Limit / Power\n    float3 compressionFuncParams;\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    // When solving for the target gamut boundary\n    // how many search interval halving steps to perform\n    int boundarySolvePrecision;\n\n    // Number of iterations to converge on the uncompressed J value \n    // Because of the compression focus point changes depending on the J value of the uncompressed sample\n    // we cannot perfectly invert it since the original J value has now been changed by the forward compression\n    // we can converge on a reasonable approximation of the original J value by iterating the inverse compression\n    // although this is quite an expensive operation\n    int inverseSolverIterations;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n\n    float3x3 XYZ_to_LMS_ZCAM;\n    float zcam_rho;\n\n\n    // Tonescale select\n    bool mmTonescaleMode;\n    // OpenDRT tonescale parameters\n    float Lp;\n    float su;\n    float c0;\n    float cs;\n    float c1;\n    float p;\n    float w1;\n    float s1;\n    float ex;\n    float eb;\n    float e0;\n    float s0;\n    float fl;\n    float dch;\n    float sat;\n    float mmScaleFactor;\n\n  local:\n\n    // constants\n    float HALF_MIN;\n    float HALF_MAX;\n\n    // ZCAM vars\n    float zcam_L_A;\n    float zcam_F_b;\n    float zcam_F_L;\n    float zcam_cb;\n    float zcam_cg;\n    float zcam_c1;\n    float zcam_c2;\n    float zcam_c3;\n    float zcam_eta;\n    // float zcam_rho;\n    float zcam_luminance_shift;\n    float zcam_viewing_conditions_coeff;\n\n    // CAT vars\n    float cat_adaptDegree;\n\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // SSTS constants\n    float ssts_min_stop_sdr;\n    float ssts_max_stop_sdr;\n    float ssts_min_stop_rrt;\n    float ssts_max_stop_rrt;\n    float ssts_min_lum_sdr;\n    float ssts_max_lum_sdr;\n    float ssts_min_lum_rrt;\n    float ssts_max_lum_rrt;\n    int ssts_n_knots_low;\n    int ssts_n_knots_high;\n    float3x3 ssts_m1;\n\n    // SSTS tables\n    // using the float4 type to store the two 2D vectors\n    // because Blink does not support generic array assignments\n    float4 ssts_minTable;\n    float4 ssts_maxTable;\n    float4 ssts_bendsLow;\n    float4 ssts_bendsHigh;\n\n    // SSTS parameters\n    float3 ssts_min_pt;\n    float3 ssts_mid_pt;\n    float3 ssts_max_pt;\n    float ssts_knotIncLow;\n    float ssts_knotIncHigh;\n    float ssts_pctLow;\n    float ssts_pctHigh;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n    float3x3 ssts_coefsLow;\n    float3x3 ssts_coefsHigh;\n\n    float ssts_expShift;\n    float3 ssts_paramMin;\n    float3 ssts_paramMid;\n    float3 ssts_paramMax;\n\n\n    // matrix vars\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    // float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 refWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // the maximum colorfulness value of the limiting gamut\n    float limitMmax;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given ZCAM hue (h) value \n    // one must search the table entries for the mathcing entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since tempoary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n\n    // local version of the public focusDistance parameter\n    // this one will be clamped to a value > 0.0\n    float focusDistanceClamped;\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // Two-Stage chromatic adaptation transforms as proposed by  Zhai, Q., & Luo, M. R. (2018)\n  // https://opg.optica.org/oe/fulltext.cfm?uri=oe-26-6-7724\n  // https://github.com/colour-science/colour/blob/e5fa0790adcc3e5df5fa42ddf2bb75214c8cf59c/colour/adaptation/zhai2018.py\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n  // apply chromatic adaptation transform to 'XYZ' from 'XYZ_ws' to 'XYZ_wd' white points\n  // 'type' selects the cone fundamentals matrix (exept for Zhai2018 which uses a 2-stage tranforms based on CATO2 fundamentals)\n  // 'adaptDegree' sets the degree of adaptation for the Zhai2018 model\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type, float adaptDegree )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    // if(LMS_ws.x == 0.0f)\n    // \{\n    //   LMS_ws.x = 0.000001f;\n    // \}\n    // if(LMS_ws.y == 0.0f)\n    // \{\n    //   LMS_ws.y = 0.000001f;\n    // \}\n    // if(LMS_ws.z == 0.0f)\n    // \{\n    //   LMS_ws.z = 0.000001f;\n    // \}\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM intermediate Izazbz colorspace\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = zcam_cb * XYZD65.x - (zcam_cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = zcam_cg * XYZD65.y - (zcam_cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( zcam_c1 + zcam_c2 * spow((LMS.x/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.x/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.y = spow( ( zcam_c1 + zcam_c2 * spow((LMS.y/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.y/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.z = spow( ( zcam_c1 + zcam_c2 * spow((LMS.z/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.z/10000.0f),zcam_eta) ), zcam_rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    // return float3(LMS_to_Izazbz\[0]\[0], LMS_to_Izazbz\[0]\[1], LMS_to_Izazbz\[0]\[2]);\n    return Izazbz;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to XYZ tristimulus values\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((zcam_c1-spow(LMSp.x,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.x,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.y = 10000.0f*spow((zcam_c1-spow(LMSp.y,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.y,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.z = 10000.0f*spow((zcam_c1-spow(LMSp.z,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.z,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(zcam_cb-1.0f)*XYZpD65.z)/zcam_cb;\n    XYZD65.y = (XYZpD65.y+(zcam_cg-1.0f)*XYZD65.x)/zcam_cg;\n    return XYZD65;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz, int viewingConditions )\n  \{\n    float3 JMh = 0.0f;\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(zcam_F_L, 0.2f)) / (pow(zcam_F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n    // return float3(Qz, Qzw, JMh.z);\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to the ZCAM intermediate Izazbz colorspace\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz, int viewingConditions )\n  \{\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n    float Qzm = spow(zcam_F_s, 2.2f) * spow(zcam_F_b, 0.5f) * spow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * zcam_F_s) / spow(zcam_F_b, 0.12f)) * Qzm;\n    float Izp = spow(zcam_F_b, 0.12f) / (1.6f * zcam_F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * spow(refWhiteIz, 0.78f) * spow(zcam_F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * spow(zcam_F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType, cat_adaptDegree)), refWhiteIzazbz.x, viewingConditions);\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x, viewingConditions)), d65White, refWhite, catType, cat_adaptDegree);\n  \}\n\n\n  // check if the 3D point 'v' is inside a cube with the dimensions cubeSize x cubeSize x cubeSize \n  // the 'smoothing' parameter rounds off the edges and corners of the cube with the exception of the 0,0,0 and cubeSize x cubeSize x cubeSize corners\n  // a smoothing value of 0.0 applies no smoothing and 1.0 the maximum amount (smoothing values > 1.0 result in undefined behavior )\n  int isInsideCube( float3 v, float cubeSize, float smoothing)\n  \{\n    float3 normv = v / cubeSize;\n\n    float minv = min(normv.x, min(normv.y, normv.z));\n    float maxv = max(normv.x, max(normv.y, normv.z));\n\n    if( smoothing <= 0.0f )\n    \{\n      // when not smoothing we can use a much simpler test\n      if(minv < 0.0f || maxv > 1.0f)\n      \{\n        return 0;\n      \}\n\n      return 1;\n    \}\n\n    float3 clamped = normv;\n\n    float radius = smoothing/2.0f;\n\n    radius = clamp(radius*maxv*(1.0f-minv), 0.0f, radius);\n\n    clamped.x = clamp(normv.x, radius, 1.0f-radius);\n    clamped.y = clamp(normv.y, radius, 1.0f-radius);\n    clamped.z = clamp(normv.z, radius, 1.0f-radius);\n\n\n    if( length(normv - clamped ) > radius)\n    \{\n      return 0;\n    \}\n\n    return 1;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n\n  // convert RGB values in the input colorspace to the ZCAM intermediate Izazbz colorspace\n  float3 input_RGB_to_Izazbz(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAX range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAX, HALF_MAX);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    // assuming 'fully adapted', dark' viewing conditions for input image (does that make sense?)\n    return XYZ_to_Izazbz(apply_CAT(luminanceXYZ, inWhite, d65White, catType, 1.0f));\n    // return apply_CAT(luminanceXYZ, inWhite, d65White, catType, 1.0f);\n  \}\n\n\n  // convert values in the ZCAM intermediate Izazbz colorspace to RGB values in the input colorspace\n  float3 Izazbz_to_input_RGB(float3 Izazbz)\n  \{\n    float3 luminanceXYZ = Izazbz_to_XYZ(Izazbz);\n    luminanceXYZ = apply_CAT(luminanceXYZ, d65White, inWhite, catType, 1.0f);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 RGB = luminanceToEncoding3(encodingIn, luminanceRGB);\n    return RGB;\n  \}\n\n  // convert RGB values in the output colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  // find the JM coordinates of the smoothed boundary of the limiting gamaut in ZCAM at the hue slice 'h' \n  // by searching along the line defined by 'JMSource' and 'JMFocus'\n  // the function will search outwards from where the line intersects the achromatic axis with a staring incement of 'startStepSize'\n  // once the boundary has been crossed it will search in the opposite direction with half the step size\n  // and will repeat this as as many times as is set by the 'precision' paramter\n  float2 findBoundary(float2 JMSource, float2 JMFocus, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB, float smoothing, int precision, float startStepSize )\n  \{\n\n    float2 achromaticIntercept = float2(JMFocus.x - (((JMSource.x-JMFocus.x) / (JMSource.y-JMFocus.y))*JMFocus.y), 0.0f);\n\n    if( achromaticIntercept.x <= 0.0f || achromaticIntercept.x >= limitJmax )\n    \{\n       return achromaticIntercept;\n    \}\n\n\n    float stepSize = startStepSize;\n    float2 unitVector = normalize(achromaticIntercept - JMFocus);\n    float2 JMtest = achromaticIntercept;\n    int searchOutwards = 1;\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMtest = JMtest + unitVector * stepSize;\n        int inside = isInsideCube( vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( float3(JMtest.x, JMtest.y, h), XYZw, XYZd65, viewingConditions ) / referenceLuminance ), boundaryRGB, smoothing);\n\n        if( searchOutwards )\n        \{\n          if( JMtest.x < 0.0f || JMtest.x > limitJmax || JMtest.y > limitMmax || !inside )\n          \{\n            searchOutwards = 0;\n            stepSize = -fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n        else\n        \{\n          if( JMtest.y < 0.0f || inside )\n          \{\n            searchOutwards = 1;\n            stepSize = fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n      \}\n    \}\n\n\n    float2 JMboundary = float2( clamp(JMtest.x, 0.0f, limitJmax), clamp(JMtest.y, 0.0f, limitMmax) );\n\n    return JMboundary;\n  \}\n\n\n  // apply the forward ACES SingleStageToneScale (SSTS) transfom to the linear 'x' input value and return a luminance value\n  float forwardSSTS(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsLow\[j/3]\[j%3], ssts_coefsLow\[(j+1)/3]\[(j+1)%3], ssts_coefsLow\[(j+2)/3]\[(j+2)%3]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsHigh\[j/3]\[j%3], ssts_coefsHigh\[(j+1)/3]\[(j+1)%3], ssts_coefsHigh\[(j+2)/3]\[(j+2)%3]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return spow(10.0f,logy);\n  \}\n\n\n  float forwardMmTonescale(float x)\n  \{\n      float tc = 0.0f;\n      if (x<0.18)\n      \{\n          tc = cs*spow(x,c0);\n      \}\n      else\n      \{\n          tc = c0*(x-0.18)+0.18;\n      \}\n      \n      float ts = s1*spow((tc/(s0+tc)),p);\n      float tf = ts*ts/(ts+fl);\n      float ccf = spow(s0/(x+s0),dch)*sat;\n\n      return tf;\n  \}\n\n\n\n  float inverseMmTonescale(float x)\n  \{\n\n      float tf = (x+sqrt(x*(4*fl+x)))/2;\n      float ts = s0/(spow((s1/tf),(1/p))-1);\n      float tc = 0.0f;\n      if (ts<0.18)\n      \{\n          tc = spow((ts/cs),(1/c0));\n      \}\n      else\n      \{\n          tc = (ts-0.18)/c0+0.18;\n      \}\n      float ccf = spow(s0/(tc+s0),dch)*sat;\n\n      return tc;\n  \}\n\n\n  \n  // apply the inverse ACES SingleStageToneScale (SSTS) transfomr to the 'x' luminance value and return an linear value\n  float inverseSSTS(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( ssts_coefsLow\[i/3]\[i%3] + ssts_coefsLow\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( ssts_coefsHigh\[i/3]\[i%3] + ssts_coefsHigh\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = ssts_coefsLow\[0]\[0];\n          cf.y = ssts_coefsLow\[0]\[1];\n          cf.z = ssts_coefsLow\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = ssts_coefsLow\[0]\[1];\n          cf.y = ssts_coefsLow\[0]\[2];\n          cf.z = ssts_coefsLow\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = ssts_coefsLow\[0]\[2];\n          cf.y = ssts_coefsLow\[1]\[0];\n          cf.z = ssts_coefsLow\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[0];\n          cf.y = ssts_coefsHigh\[0]\[1];\n          cf.z = ssts_coefsHigh\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[1];\n          cf.y = ssts_coefsHigh\[0]\[2];\n          cf.z = ssts_coefsHigh\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[2];\n          cf.y = ssts_coefsHigh\[1]\[0];\n          cf.z = ssts_coefsHigh\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return spow(10.0f, logx);\n  \}\n\n\n  // convert Iz to luminance\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float IzToLuminance( float Iz )\n  \{\n    float V_p = spow(Iz, 1.0f / zcam_rho);\n    float luminance = spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p * zcam_luminance_shift;\n    return luminance;\n  \}\n\n\n  // convert luminance to Iz\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float luminanceToIz( float luminance )\n  \{\n    float Y_p = spow((luminance/zcam_luminance_shift) / st2084_L_p, st2084_m_1);\n    float Iz = spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), zcam_rho);\n    return Iz;\n  \}\n\n\n  // calculate a scale factor for colorfulness\n  // based on the difference between the original and tone scaled (TS) Iz values\n  // we are only interested in the differences above mid grey\n  // so we first offset the original Iz values to align 18% it with the mid point of the IzTS value\n  float highlightDesatFactor( float Iz, float IzTS )\n  \{\n\n    float linear = IzToLuminance(Iz) / referenceLuminance;\n\n    // no highlight desat below SSTS mid point\n    if( linear < 0.18f )\n    \{\n      return 1.0f;\n    \}\n\n    float IzMid   = luminanceToIz(0.18f * referenceLuminance);\n    float IzMidTS = luminanceToIz(sstsLuminance.y);\n\n    float IzAligned = Iz + IzMidTS - IzMid;\n\n    float desatFactor = 1.0f - clamp( compressPowerP( (log10(max(HALF_MIN, IzAligned)) - log10(max(HALF_MIN, IzTS))) * desatHighlights, compressionFuncParams.x, HALF_MAX, compressionFuncParams.z, 0 ), 0.0f, 1.0f);\n\n    return desatFactor;\n  \}\n\n\n  float3 forwardTonescale( float3 inputIzazbz )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing to do here except converting to JMh\n      return Izazbz_to_JMh(inputIzazbz, refWhiteIzazbz.x, 0);\n    \}\n\n    float linear = IzToLuminance(inputIzazbz.x) / referenceLuminance;\n\n    float luminanceTS = 50.0f;\n\n    // swtich for testing out the MM tonescale from Jed\n    if( mmTonescaleMode )\n    \{\n        luminanceTS = forwardMmTonescale(linear) * mmScaleFactor;\n    \}\n    else \{\n        luminanceTS = forwardSSTS(linear, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    \}\n\n\n    float IzTS = luminanceToIz(luminanceTS);\n\n    float3 outputIzazbz = inputIzazbz;\n\n    if( applySsts )\n    \{\n      outputIzazbz.x = IzTS;\n    \}\n\n    // convert the result to JMh\n    float3 outputJMh = Izazbz_to_JMh(outputIzazbz, refWhiteIzazbz.x, 0);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(inputIzazbz.x, IzTS);\n      outputJMh.y = outputJMh.y * factM;\n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    float3 Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing else to do here\n      return Izazbz;\n    \}\n\n    float luminance = IzToLuminance(Izazbz.x);\n\n    // Dummy value to init the var\n    float linear = 50.0f;\n    // swtich for testing out the MM tonescale from Jed\n    if( mmTonescaleMode )\n    \{\n        linear = inverseMmTonescale(luminance/mmScaleFactor);\n    \}\n    else \{\n        linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    \}\n    \n    \n    float Iz = luminanceToIz(linear*referenceLuminance);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(Iz, Izazbz.x);\n      JMh.y = JMh.y / factM;\n      Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n      luminance = IzToLuminance(Izazbz.x);\n      if( mmTonescaleMode )\n      \{\n        linear = inverseMmTonescale(luminance/mmScaleFactor);\n      \}\n      else\n      \{\n        linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n      \}\n      Iz = luminanceToIz(linear*referenceLuminance);\n    \}\n\n    if( applySsts )\n    \{\n      Izazbz.x = Iz;\n    \}\n\n    return Izazbz;\n  \}\n\n\n  // compress the ZCAM JM values into the limiting gamut by projecting them towards a focus point beyond the achromatic axis\n  // in order to avoid the gamut compression to also compress black and white tones towards the focus point\n  // (which would result in lifed blacks and crushed highlights)\n  // we offset the focus further away from the achromatic axis the closer the lightness of a sample is to the zero or the limitJmax value\n  // a far away focus point means the compression vector becomes close to orthogonal to the lightness axis preserving black & white lightness\n  // the 'distanceGainCalcJ' paramter should be set to inputJMh.x for the forward direction\n  // and to the best guess of the original, uncompressed values for the inverse direction\n  // this is used for iteratively converging on the original, uncompressed value of J which would have gotten obfuscated by the forward transform\n  float3 compressGamut( float3 inputJMh, int invert, float distanceGainCalcJ )\n  \{\n    if( ! applyGamutCompression )\n    \{\n      return inputJMh;\n    \}\n\n    float sstsMidJ = XYZ_to_ZCAM_JMh( refWhite * sstsLuminance.y, refWhite, d65White, viewingConditions ).x;\n    float2 JMinput = float2(inputJMh.x, inputJMh.y);\n    float2 JMcusp = cuspFromTable( inputJMh.z);\n\n    float focusJ = lerp(JMcusp.x, sstsMidJ, cuspMidBlend);\n\n    float focusDistanceGain = 1.0f;\n\n    if( distanceGainCalcJ > focusJ )\n    \{\n      focusDistanceGain = (limitJmax - focusJ) / max(0.0001f, (limitJmax - min(limitJmax, distanceGainCalcJ)));\n    \}\n    else\n    \{\n      focusDistanceGain = (focusJ) / max(0.0001f, distanceGainCalcJ); \n    \}\n\n    float2 JMfocus = float2( focusJ, -JMcusp.y*focusDistanceClamped*focusDistanceGain );\n    float2 vecToFocus = (JMfocus - JMinput);\n    float2 achromaticIntercept = float2(JMfocus.x - (((JMinput.x-JMfocus.x) / (JMinput.y-JMfocus.y))*JMfocus.y), 0.0f);\n\n    // to reduce the number of expensive boundary finding iterations needed\n    // we taking an educated guess at a good starting step size\n    // based on how far the sample is either above or below the gamut cusp\n    float cuspToTipRatio;\n    if( JMinput.x > JMcusp.x )\n    \{\n      cuspToTipRatio = (JMinput.x - JMcusp.x) / (limitJmax - JMcusp.x);\n    \}\n    else\n    \{\n      cuspToTipRatio = (JMcusp.x - JMinput.x) / (JMcusp.x);\n    \}\n\n    float startStepSize = lerp(JMcusp.y / 3.0f, 0.1f, cuspToTipRatio);\n    float2 JMboundary = findBoundary(JMinput, JMfocus,  inputJMh.z, refWhite, d65White, XYZ_to_RGB_limit, smoothCusps, boundarySolvePrecision, startStepSize);\n    float normFact = 1.0f / max(0.0001f, length(JMboundary - achromaticIntercept));\n    float v = length(JMinput-achromaticIntercept) * normFact;\n    float vCompressed = compressPowerP(v, compressionFuncParams.x, compressionFuncParams.y, compressionFuncParams.z, invert);\n    float2 JMcompressed = 0.0f;\n    // hack to stop nan values after compression\n    if (JMinput.y != 0.0f)\n    \{\n      JMcompressed = achromaticIntercept + normalize(JMinput-achromaticIntercept)*vCompressed/normFact;\n    \}\n    else\n    \{\n      JMcompressed = JMinput;\n    \}\n    return float3(JMcompressed.x, JMcompressed.y, inputJMh.z);\n  \}\n\n\n  // apply the forward gamut compression to the limiting primaries\n  float3 compressGamutForward( float3 JMh )\n  \{\n    float3 JMhcompressed = compressGamut( JMh, 0, JMh.x );\n    // Hack to deal with weird zero values on output\n    // JMhcompressed.x = min(300.0f,JMhcompressed.x);\n    return JMhcompressed;\n  \}\n\n\n  // apply the inverse gamut compression\n  // and iterate a given number of times to reconstruct the original J value\n  float3 compressGamutInverse( float3 JMh )\n  \{\n    float3 JMhuncompressed;\n    float distanceGainCalcJ = JMh.x;\n\n    for( int i = 0; i < inverseSolverIterations; ++i )\n    \{\n      JMhuncompressed = compressGamut( JMh, 1, distanceGainCalcJ );\n      distanceGainCalcJ = JMhuncompressed.x;\n    \}\n\n    return JMhuncompressed;\n  \}\n\n\n  void init()\n  \{\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    zcam_L_A = referenceLuminance * backgroundLuminance / 100.0f;\n    zcam_F_b = sqrt(backgroundLuminance/referenceLuminance);\n    zcam_F_L = 0.171f*spow(zcam_L_A, 1.0f/3.0f) * (1.0f-exp(-48.0f/9.0f*zcam_L_A));\n\n    if( discountIlluminant )\n    \{\n      cat_adaptDegree = 1.0f;\n    \}\n    else\n    \{\n      float viewingConditionsCoeff = 1.0f;\n\n      if( viewingConditions == 0 )\n      \{\n        viewingConditionsCoeff = 0.8f;\n      \}\n      else if( viewingConditions == 1 )\n      \{\n        viewingConditionsCoeff = 0.9f;\n      \}\n      else if( viewingConditions == 2 )\n      \{\n        viewingConditionsCoeff = 1.0f;\n      \}\n\n      cat_adaptDegree = viewingConditionsCoeff * (1.0f - (1.0f / 3.6f) * exp((-zcam_L_A - 42.0f) / 92.0f));\n    \}\n\n    zcam_cb  = 1.15f;\n    zcam_cg  = 0.66f;\n    zcam_c1  = 3424.0f / spow(2.0f,12.0f);\n    zcam_c2  = 2413.0f / spow(2.0f, 7.0f);\n    zcam_c3  = 2392.0f / spow(2.0f, 7.0f);\n    zcam_eta = 2610.0f / spow(2.0f,14.0f);\n    // zcam_rho = 1.7f * 2323.0f / pow(2.0f,5.0f);\n    zcam_luminance_shift = 1.0f / (-0.20151000f + 1.12064900f + 0.05310080f);\n\n    zcam_viewing_conditions_coeff = 1.0f;\n\n    if( viewingConditions == 0 )\n    \{\n      zcam_viewing_conditions_coeff = 0.525f;\n    \}\n    else if( viewingConditions == 1 )\n    \{\n      zcam_viewing_conditions_coeff = 0.59f;\n    \}\n    else if( viewingConditions == 2 )\n    \{\n      zcam_viewing_conditions_coeff = 0.69f;\n    \}\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    ssts_min_stop_sdr =  -6.5f;\n    ssts_max_stop_sdr =   6.5f;\n    ssts_min_stop_rrt = -15.0f;\n    ssts_max_stop_rrt =  18.0f;\n    ssts_min_lum_sdr = 0.02f;\n    ssts_max_lum_sdr = 48.0f;\n    ssts_min_lum_rrt = 0.0001f;\n    ssts_max_lum_rrt = 10000.0f;\n    ssts_n_knots_low = 4;\n    ssts_n_knots_high = 4;\n\n    ssts_minTable = float4(log10(ssts_min_lum_rrt), ssts_min_stop_rrt, log10(ssts_min_lum_sdr), ssts_min_stop_sdr);\n    ssts_maxTable = float4(log10(ssts_max_lum_sdr), ssts_max_stop_sdr, log10(ssts_max_lum_rrt), ssts_max_stop_rrt);\n    ssts_bendsLow = float4(ssts_min_stop_rrt, 0.18f, ssts_min_stop_sdr, 0.35f);\n    ssts_bendsHigh = float4(ssts_max_stop_sdr, 0.89f, ssts_max_stop_rrt, 0.90f);\n\n    float ssts_m1_data\[]=\{ 0.5f,-1.0f, 0.5f,\n                          -1.0f, 1.0f, 0.0f,\n                           0.5f, 0.5f, 0.0f \};\n    ssts_m1.setArray(ssts_m1_data);\n\n    ssts_min_pt.x = 0.18f * spow(2.0f, lerp1D(ssts_minTable, log10(sstsLuminance.x)));\n    ssts_min_pt.y = sstsLuminance.x;\n    ssts_min_pt.z = 0.0f;\n\n    ssts_mid_pt = float3(0.18f, 4.8f, 1.55f);\n\n    ssts_max_pt.x = 0.18f * spow(2.0f, lerp1D(ssts_maxTable, log10(sstsLuminance.z)));\n    ssts_max_pt.y = sstsLuminance.z;\n    ssts_max_pt.z = 0.0f;\n\n    ssts_knotIncLow  = (log10(ssts_mid_pt.x) - log10(ssts_min_pt.x)) / 3.0f;\n    ssts_knotIncHigh = (log10(ssts_max_pt.x) - log10(ssts_mid_pt.x)) / 3.0f;\n    ssts_pctLow  = lerp1D(ssts_bendsLow,  log2(ssts_min_pt.x / 0.18f));\n    ssts_pctHigh = lerp1D(ssts_bendsHigh, log2(ssts_max_pt.x / 0.18f));\n\n    \n    float ssts_coefsLow_data\[] = \{\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      log10(ssts_min_pt.y) + ssts_pctLow*(log10(ssts_mid_pt.y)-log10(ssts_min_pt.y)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    float sssts_coefsHigh_data\[] = \{\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      log10(ssts_mid_pt.y) + ssts_pctHigh*(log10(ssts_max_pt.y)-log10(ssts_mid_pt.y)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    ssts_coefsLow.setArray(ssts_coefsLow_data);\n    ssts_coefsHigh.setArray(sssts_coefsHigh_data);\n\n    ssts_paramMin = ssts_min_pt;\n    ssts_paramMid = ssts_mid_pt;\n    ssts_paramMax = ssts_max_pt;\n    ssts_expShift = log2(inverseSSTS(sstsLuminance.y, ssts_min_pt, ssts_paramMid, ssts_max_pt)) - log2(0.18f);\n    ssts_paramMin.x = spow(2.0f, (log(ssts_paramMin.x) / log(2.0f) - ssts_expShift));\n    ssts_paramMid.x = spow(2.0f, (log(0.18f          ) / log(2.0f) - ssts_expShift));\n    ssts_paramMax.x = spow(2.0f, (log(ssts_paramMax.x) / log(2.0f) - ssts_expShift));\n\n\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11f;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0001f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    // XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n      \n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n\n    // limitMmax (asumed to coincide with one of the RGBCMY corners of the limitRGB cube)\n    float3 gamutCornersTable\[6];\n    gamutCornersTable\[0] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 0.0f));\n    gamutCornersTable\[1] = limit_RGB_to_JMh(float3(1.0f, 1.0f, 0.0f));\n    gamutCornersTable\[2] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 0.0f));\n    gamutCornersTable\[3] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 1.0f));\n    gamutCornersTable\[4] = limit_RGB_to_JMh(float3(0.0f, 0.0f, 1.0f));\n    gamutCornersTable\[5] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 1.0f));\n\n    limitMmax = 0.0f;\n    for( int i = 0; i < 6; ++i )\n    \{\n      limitMmax = max(limitMmax, gamutCornersTable\[i].y);\n    \}\n\n    // ensure positive, non-zero focus depth\n    // to avoid the gamut boundary search vector becoming zero for achromatic colors\n    // which will cause the boundary search loop to continue forever and the node to hang\n    focusDistanceClamped = max(0.01f, focusDistance);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n\n    if( invert )\n    \{\n      float3 JMh = output_RGB_to_JMh(srcRGB);\n      JMh = compressGamutInverse(JMh);\n      float3 inputIzazbz = inverseTonescale(JMh);\n      dstRGB = Izazbz_to_input_RGB(inputIzazbz);\n    \}\n    else\n    \{\n      float3 inputIzazbz = input_RGB_to_Izazbz(srcRGB);\n      float3 JMh = forwardTonescale(inputIzazbz);\n      JMh = compressGamutForward(JMh);\n      dstRGB = JMh_to_output_RGB(JMh);\n      // diagnostic = Izazbz_to_JMh(inputIzazbz, 0.31334f, 0);\n      diagnostic =  dstRGB;\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_ZCAM_v12_Kernel_encodingIn {{parent.encoding_in}}
  DRT_ZCAM_v12_Kernel_primariesIn {{parent.primaries_in}}
  DRT_ZCAM_v12_Kernel_catType {{parent.cat_type}}
  DRT_ZCAM_v12_Kernel_discountIlluminant {{parent.discount_illuminant}}
  DRT_ZCAM_v12_Kernel_referenceLuminance {{parent.reference_luminance}}
  DRT_ZCAM_v12_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_ZCAM_v12_Kernel_viewingConditions {{parent.viewing_conditions}}
  DRT_ZCAM_v12_Kernel_applySsts {{parent.apply_ssts}}
  DRT_ZCAM_v12_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_ZCAM_v12_Kernel_applyHighlightDesat {{parent.apply_highlight_desat}}
  DRT_ZCAM_v12_Kernel_desatHighlights {{parent.desat_highlights}}
  DRT_ZCAM_v12_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_ZCAM_v12_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_ZCAM_v12_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_ZCAM_v12_Kernel_focusDistance {{parent.focus_distance}}
  DRT_ZCAM_v12_Kernel_compressionFuncParams {{parent.compression_params.x} {parent.compression_params.y} {parent.compression_params.z}}
  DRT_ZCAM_v12_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_ZCAM_v12_Kernel_boundarySolvePrecision {{parent.solve_precision}}
  DRT_ZCAM_v12_Kernel_inverseSolverIterations {{parent.inverse_solver_iterations}}
  DRT_ZCAM_v12_Kernel_encodingOut {{parent.encoding_out}}
  DRT_ZCAM_v12_Kernel_primariesOut {{parent.primaries_out}}
  DRT_ZCAM_v12_Kernel_clampOutput {{parent.clamp_output}}
  DRT_ZCAM_v12_Kernel_invert {{parent.invert}}
  DRT_ZCAM_v12_Kernel_XYZ_to_LMS_ZCAM {
      {{DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler}}
      {{DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler}}
      {{DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink3.preMatrix.matrix*matrixScaler}}
    }
  DRT_ZCAM_v12_Kernel_zcam_rho {{"1.7 * 2523.0 / pow(2.0,5.0)"}}
  DRT_ZCAM_v12_Kernel_mmTonescaleMode true
  DRT_ZCAM_v12_Kernel_Lp {{parent.ssts_luminance.z}}
  DRT_ZCAM_v12_Kernel_su 2
  DRT_ZCAM_v12_Kernel_c0 1.2
  DRT_ZCAM_v12_Kernel_cs {{0.18**(1-DRT_ZCAM_v12_Kernel_c0)}}
  DRT_ZCAM_v12_Kernel_c1 1.1
  DRT_ZCAM_v12_Kernel_p {{DRT_ZCAM_v12_Kernel_c1*(0.9+0.05*DRT_ZCAM_v12_Kernel_su)}}
  DRT_ZCAM_v12_Kernel_w1 {{(0.595*DRT_ZCAM_v12_Kernel_Lp/10000)**0.931+1.037}}
  DRT_ZCAM_v12_Kernel_s1 {{DRT_ZCAM_v12_Kernel_w1*DRT_ZCAM_v12_Kernel_Lp/100}}
  DRT_ZCAM_v12_Kernel_ex -0.26
  DRT_ZCAM_v12_Kernel_eb 0.08
  DRT_ZCAM_v12_Kernel_e0 {{2**(DRT_ZCAM_v12_Kernel_ex+DRT_ZCAM_v12_Kernel_eb*log(DRT_ZCAM_v12_Kernel_s1)/log(2))}}
  DRT_ZCAM_v12_Kernel_s0 {{(DRT_ZCAM_v12_Kernel_s1/DRT_ZCAM_v12_Kernel_e0)**(1/DRT_ZCAM_v12_Kernel_c1)}}
  DRT_ZCAM_v12_Kernel_fl 0.01
  DRT_ZCAM_v12_Kernel_dch 0.55
  DRT_ZCAM_v12_Kernel_sat {{max(1,1.125-0.00025*DRT_ZCAM_v12_Kernel_Lp)}}
  DRT_ZCAM_v12_Kernel_mmScaleFactor 100
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -232
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Clamp {
  channels rgb
  minimum_enable false
  maximum {{parent.parent.DRT_ZCAM_IzMh_v12_Blink3.ssts_luminance.z/100}}
  name Clamp1
  xpos -908
  ypos -180
 }
 Output {
  name Output1
  xpos -908
  ypos -128
 }
end_group
set N46997200 [stack 0]
push $N1aee8c00
Dot {
 name Dot2
 xpos 15
 ypos 261
}
set N44f6dc00 [stack 0]
push $N1aee9800
Viewer {
 inputs 3
 frame 1
 frame_range 1-100
 gl_buffer_depth half-float
 viewerProcess None
 name Viewer1
 xpos 759
 ypos 661
}
Colorspace {
 inputs 0
 primary_in DCI-P3
 colorspace_out sRGB
 primary_out DCI-P3
 name Colorspace2
 xpos -200
 ypos 428
}
Group {
 inputs 0
 name GamutToXYZ3
 tile_color 0xbd91c9ff
 label "APS4 to XYZ"
 xpos 854
 ypos 50
 addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
 addUserKnob {35 colorspace_presets l preset M {colorspace/ACES "knobs this \{rxy \{0.73470 0.26530\} gxy \{0.00000 1.00000\} bxy \{0.00010 -0.07700\} wxy \{0.32168 0.33767\} src_colorspace_name \{ACES\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ACEScg "knobs this \{rxy \{0.713 0.293\} gxy \{0.165 0.830\} bxy \{0.128 0.044\} wxy \{0.32168 0.33767\} src_colorspace_name \{ACEScg\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Filmlight E-Gamut" "knobs this \{rxy \{0.8 0.3177\} gxy \{0.18 0.9\} bxy \{0.065 -0.0805\} wxy \{0.3127 0.329\} src_colorspace_name \{Filmlight E-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/Rec709 "knobs this \{rxy \{0.64000 0.33000\} gxy \{0.30000 0.60000\} bxy \{0.15000 0.06000\} wxy \{0.3127 0.329\} src_colorspace_name \{Rec709\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/Rec2020 "knobs this \{rxy \{0.70800 0.29200\} gxy \{0.17000 0.79700\} bxy \{0.13100 0.04600\} wxy \{0.3127 0.329\} src_colorspace_name \{Rec2020\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3D60 "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.32168 0.33767\} src_colorspace_name \{P3D60\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3D65 "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.3127 0.329\} src_colorspace_name \{P3D65\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3DCI "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.314 0.351\} src_colorspace_name \{P3DCI\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Arri AlexaWideGamut" "knobs this \{rxy \{0.68400 0.31300\} gxy \{0.22100 0.84800\} bxy \{0.08610 -0.10200\} wxy \{0.3127 0.329\} src_colorspace_name \{Arri AlexaWideGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDDRAGONcolor "knobs this \{rxy \{0.753044222785 0.327830576682\} gxy \{0.299570228481 0.700699321956\} bxy \{0.079642066735 -0.0549379510888\} wxy \{0.321683187724 0.337673316035\} src_colorspace_name \{REDDRAGONcolor\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDDRAGONcolor2 "knobs this \{rxy \{0.753044491143 0.327831029513\} gxy \{0.299570490451 0.700699415614\} bxy \{0.145011584278 0.0510971250879\} wxy \{0.321683210353 0.337673610062\} src_colorspace_name \{REDDRAGONcolor2\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor "knobs this \{rxy \{0.699747001291 0.329046930313\} gxy \{0.304264039024 0.623641145129\} bxy \{0.134913961296 0.0347174412813\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor2 "knobs this \{rxy \{0.878682510476 0.32496400741\} gxy \{0.300888714367 0.679054755791\} bxy \{0.0953986946056 -0.0293793268343\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor2\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor3 "knobs this \{rxy \{0.701181035906 0.329014155583\} gxy \{0.300600304652 0.683788834269\} bxy \{0.108154455624 -0.00868817578666\} wxy \{0.321683210353 0.337673610062\} src_colorspace_name \{REDcolor3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor4 "knobs this \{rxy \{0.701180591892 0.329013699116\} gxy \{0.300600395529 0.683788824257\} bxy \{0.145331946229 0.0516168036226\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor4\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDWideGamutRGB "knobs this \{rxy \{0.780308 0.304253\} gxy \{0.121595 1.493994\} bxy \{0.095612 -0.084589\} wxy \{0.3127 0.329\} src_colorspace_name \{REDWideGamutRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/GoPro Protune Native" "knobs this \{rxy \{0.69848046 0.19302645\} gxy \{0.32955538 1.02459662\} bxy \{0.10844263 -0.03467857\} wxy \{0.3127 0.329\} src_colorspace_name \{GoPro Protune Native\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/CanonCinemaGamut "knobs this \{rxy \{0.74 0.27\} gxy \{0.17 1.14\} bxy \{0.08 -0.1\} wxy \{0.3127 0.329\} src_colorspace_name \{CanonCinemaGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SonySGamut "knobs this \{rxy \{0.73 0.28\} gxy \{0.14 0.855\} bxy \{0.1 -0.05\} wxy \{0.3127 0.329\} src_colorspace_name \{SonySGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SonySGamut3Cine "knobs this \{rxy \{0.766 0.275\} gxy \{0.225 0.8\} bxy \{0.089 -0.087\} wxy \{0.3127 0.329\} src_colorspace_name \{SonySGamut3Cine\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/PanasonicVGamut "knobs this \{rxy \{0.730 0.280\} gxy \{0.165 0.840\} bxy \{0.100 -0.030\} wxy \{0.3127 0.329\} src_colorspace_name \{PanasonicVGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/DJI D-Gamut" "knobs this \{rxy \{0.71 0.31\} gxy \{0.21 0.88\} bxy \{0.09 -0.08\} wxy \{0.3127 0.329\} src_colorspace_name \{DJI D-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Fujifilm F-Gamut" "knobs this \{rxy \{0.70800 0.29200\} gxy \{0.17000 0.79700\} bxy \{0.13100 0.04600\} wxy \{0.3127 0.329\} src_colorspace_name \{Fujifilm F-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMDFilmV1 "knobs this \{rxy \{0.9173 0.2502\} gxy \{0.2833 1.7072\} bxy \{0.0856 -0.0708\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMDFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD4kFilmV1 "knobs this \{rxy \{0.7422 0.2859\} gxy \{0.4140 1.3035\} bxy \{0.0342 -0.0833\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMD4kFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD4kFilmV3 "knobs this \{rxy \{1.0625 0.3948\} gxy \{0.3689 0.7775\} bxy \{0.0956 -0.0332\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMD4kFilmV3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD46kFilmV1 "knobs this \{rxy \{0.9175 0.2983\} gxy \{0.2983 1.2835\} bxy \{0.0756 -0.0860\} wxy \{0.3127 0.329\} src_colorspace_name \{BMD46kFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD46kFilmV3 "knobs this \{rxy \{0.8608 0.3689\} gxy \{0.3282 0.6156\} bxy \{0.0783 -0.0233\} wxy \{0.3127 0.329\} src_colorspace_name \{BMD46kFilmV3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMDWideGamutV4 "knobs this \{rxy \{0.7177 0.3171\} gxy \{0.2280 0.8616\} bxy \{0.1006 -0.0820\} wxy \{0.3127 0.329\} src_colorspace_name \{BMDWideGamutV4\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/AdobeRGB\t" "knobs this \{rxy \{0.6400 0.3300\} gxy \{0.2100 0.7100\} bxy \{0.1500 0.0600\} wxy \{0.3127 0.329\} src_colorspace_name \{AdobeRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/AdobeWideGamutRGB "knobs this \{rxy \{0.7347 0.2653\} gxy \{0.1152 0.8264\} bxy \{0.1566 0.0177\} wxy \{0.3457 0.3585\} src_colorspace_name \{AdobeWideGamutRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ROMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01  8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{ROMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/RIMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01 8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{RIMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ERIMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01 8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{ERIMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ProPhotoRGB "knobs this \{rxy \{0.734699 0.265301\} gxy \{0.159597 0.840403\} bxy \{0.036598 0.000105\} wxy \{0.345704 0.358540\} src_colorspace_name \{ProPhotoRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/RusselRGB "knobs this \{rxy \{0.6900 0.3100\} gxy \{0.1800 0.7700\} bxy \{0.1000 0.0200\} wxy \{0.33243 0.34744\} src_colorspace_name \{RusselRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SharpRGB "knobs this \{rxy \{0.6898 0.3206\} gxy \{0.0736 0.9003\} bxy \{0.1166 0.0374\} wxy \{0.33333333 0.33333333\} src_colorspace_name \{SharpRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/AppleRGB "knobs this \{rxy \{0.6250 0.3400\} gxy \{0.2800 0.5950\} bxy \{0.1550 0.0700\} wxy \{0.3127 0.329\} src_colorspace_name \{AppleRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BestRGB "knobs this \{rxy \{0.735191637630662 0.264808362369338\} gxy \{0.215336134453781 0.774159663865546\} bxy \{0.130122950819672 0.034836065573770\} wxy \{0.3457 0.3585\} src_colorspace_name \{BestRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/XYZ "knobs this \{rxy \{0 0\} gxy \{0 0\} bxy \{0 0\} wxy \{0 0\} src_colorspace_name \{XYZ\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()"}}
 addUserKnob {26 colorspace_chromaticities_label l " " T "<b>Colorspace Chromaticities</b>"}
 addUserKnob {12 rxy l r t "Red xy chromaticity coordinates in CIE 1931 colorspace."}
 rxy {0.96 0.37}
 addUserKnob {12 gxy l g t "Green xy chromaticity coordinates in CIE 1931 colorspace."}
 gxy {-0.03 1.1}
 addUserKnob {12 bxy l b t "Blue xy chromaticity coordinates in CIE 1931 colorspace."}
 bxy {{gxy.x} -0.09}
 addUserKnob {12 wxy l w t "Whitepoint xy chromaticity coordinates in CIE 1931 colorspace."}
 wxy {0.32168 0.33767}
 addUserKnob {1 src_colorspace_name l src}
 src_colorspace_name APS4
 addUserKnob {26 ""}
 addUserKnob {6 invert t "Invert direction of matrix: XYZtoRGB" +STARTLINE}
 addUserKnob {22 calculate_matrix l "Calculate Matrix" t "Calculate 3x3 matrix based on the specified colorspace chromaticities." T "import nuke\nfloat2 = nuke.math.Vector2\nfloat3 = nuke.math.Vector3\nfloat3x3 = nuke.math.Matrix3\nfloat4x4 = nuke.math.Matrix4\n\n\ndef get_primaries(node, dst=False):\n    # get xy coordinates from node\n    dst_pri = \['drxy', 'dgxy', 'dbxy', 'dwxy']\n    pri = \['rxy', 'gxy', 'bxy', 'wxy']\n    d = \{\}\n    for i, p in enumerate(pri):\n        if dst:\n            d\[p] = float2(node\[dst_pri\[i]].getValue()\[0], node\[dst_pri\[i]].getValue()\[1])\n        else:\n            d\[p] = float2(node\[p].getValue()\[0], node\[p].getValue()\[1])\n    return d\n\n\ndef RGBtoXYZ(xy, Y=1.0, inverse=False):\n    # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    # based on CtlColorSpace.cpp from the CTL source code : 77\n    # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    # param: Y - luminance of \"white\" - defaults to 1.0\n    # param: inverse - calculate XYZ to RGB instead\n    r = xy\['rxy']\n    g = xy\['gxy']\n    b = xy\['bxy']\n    w = xy\['wxy']\n\n    X = w.x * Y / w.y\n    Z = (1 - w.x - w.y) * Y / w.y\n\n    # Scale factors for matrix rows\n    d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y)\n\n    Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1) + \\\n            g.y * (X + Z))) / d\n    \n    Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1) +  \\\n            r.y * (X + Z))) / d\n\n    Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1) +  \\\n            r.y * (X + Z))) / d\n\n    # Assemble the matrix\n    M = float3x3()\n    M.set(  Sr * r.x, Sr * r.y, Sr * (1 - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1 - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1 - b.x - b.y))\n    if inverse:\n        M = M.inverse()\n        return M\n    else:\n        return M\n\n\ndef start():\n    node = nuke.thisNode()\n    \n    invert = node\['invert'].getValue()\n    label = node\['label']\n    \n    if invert:\n        # Convert from XYZ colorspace to Src RGB\n        mtx = RGBtoXYZ(get_primaries(node), inverse=True)\n        label.setValue('XYZ to \{0\}'.format(node\['src_colorspace_name'].getValue()))\n    else:\n        # Convert from Src RGB colorspace to XYZ\n        mtx = RGBtoXYZ(get_primaries(node))\n        label.setValue('\{0\} to XYZ'.format(node\['src_colorspace_name'].getValue()))\n\n    node\['matrix'].setValue((mtx))\n    \n   \n\nif __name__=='__main__':\n    start()" +STARTLINE}
 addUserKnob {22 create_matrix_node l "Create Matrix" t "Create ColorMatrix node with the current values." -STARTLINE T "node = nuke.thisNode()\nnode\['calculate_matrix'].execute()\nnuke.root().begin()\n_ = \[n.setSelected(False) for n in nuke.allNodes(recurseGroups=True)]\nm = nuke.createNode('ColorMatrix')\nm\['matrix'].setValue(node\['matrix'].getValue())\nm.setXYpos(node.xpos()-120, node.ypos())\nm\['label'].setValue(node\['label'].getValue())"}
 addUserKnob {41 matrix T ColorMatrix.matrix}
 addUserKnob {22 clear l Clear T "n = nuke.thisNode()\nn\['matrix'].setValue(\[1,0,0,0,1,0,0,0,1])\nn\['label'].setValue('')" +STARTLINE}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos 206
 }
 ColorMatrix {
  matrix {
      {1.009929895 -0.01972960308 -0.03755422309}
      {0.3892438412 0.7234188318 -0.112662673}
      {-0.347163409 -0.04603575915 1.402024388}
    }
  name ColorMatrix
  xpos -40
  ypos 254
 }
 Output {
  name Output
  xpos -40
  ypos 302
 }
end_group
push $N44f6dc00
Group {
 name rgbDT
 label "MM\nStock\nRec709"
 xpos -19
 ypos 343
 addUserKnob {20 Params}
 addUserKnob {41 gamut l "input gamut" T InGamut_to_XYZ.gamut}
 addUserKnob {41 Lw T ToneScale.Lw}
 addUserKnob {41 su l surround T ToneScale.su}
 addUserKnob {41 tint T Tint.tint}
 addUserKnob {26 ""}
 addUserKnob {41 eotf T InverseEOTF.eotf}
 addUserKnob {41 display_gamut l "display gamut" -STARTLINE T XYZ_to_DisplayGamut.gamut}
 addUserKnob {6 clamp -STARTLINE}
 clamp true
 addUserKnob {4 direction M {forward inverse}}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos -226
 }
set N30956000 [stack 0]
 Group {
  name EOTF
  xpos 180
  ypos -154
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf l EOTF t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG ""}}
  eotf {{parent.InverseEOTF.eotf}}
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -130
  }
set N30955c00 [stack 0]
  Expression {
   expr0 r<=0.5?r*r/3:(exp((r-_c)/_a)+_b)/12
   expr1 g<=0.5?g*g/3:(exp((g-_c)/_a)+_b)/12
   expr2 b<=0.5?b*b/3:(exp((b-_c)/_a)+_b)/12
   name HLG_InverseOETF
   xpos 620
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
  Expression {
   temp_name0 Ys
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 pow(Ys,_g-1)*r
   expr1 pow(Ys,_g-1)*g
   expr2 pow(Ys,_g-1)*b
   name HLG_OOTF
   xpos 620
   ypos -34
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lw/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lw R 600 4000}
   Lw 1000
   addUserKnob {7 Lb}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
push $N30955c00
  Expression {
   temp_name0 rp
   temp_expr0 pow(r,1/m_2)
   temp_name1 gp
   temp_expr1 pow(g,1/m_2)
   temp_name2 bp
   temp_expr2 pow(b,1/m_2)
   expr0 pow((rp-c_1)/(c_2-c_3*rp),1/m_1)
   expr1 pow((gp-c_1)/(c_2-c_3*gp),1/m_1)
   expr2 pow((bp-c_1)/(c_2-c_3*bp),1/m_1)
   name ST2084_EOTF
   xpos 510
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
  }
push $N30955c00
  Expression {
   expr0 sign(r)*pow(fabs(r),p)
   expr1 sign(g)*pow(fabs(g),p)
   expr2 sign(b)*pow(fabs(b),p)
   name Power
   xpos 400
   ypos -58
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos -10
  }
  Output {
   name Output
   xpos 400
   ypos 62
  }
 end_group
 Expression {
  expr0 r*sc
  expr1 g*sc
  expr2 b*sc
  name InvDisplayScale
  xpos 180
  ypos -130
  addUserKnob {20 Params}
  addUserKnob {7 sc}
  sc {{parent.DisplayScale.sc}}
 }
 Multiply {
  channels rgb
  value {{1/parent.Tint.value} {1/parent.Tint.value} {1/parent.Tint.value} 1}
  name InvTint
  xpos 180
  ypos -105
 }
 ColorMatrix {
  matrix {
      {{parent.Saturation.matrix} {parent.Saturation.matrix} {parent.Saturation.matrix}}
      {{parent.Saturation.matrix} {parent.Saturation.matrix} {parent.Saturation.matrix}}
      {{parent.Saturation.matrix} {parent.Saturation.matrix} {parent.Saturation.matrix}}
    }
  invert true
  name InvSaturation
  xpos 180
  ypos -81
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
    }
  invert true
  name DisplayGamut_to_XYZ
  xpos 180
  ypos -57
 }
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  invert true
  name XYZ_to_rgbDT1
  xpos 180
  ypos -33
 }
 Expression {
  temp_name0 rt
  temp_expr0 (r+sqrt(r*(4*fl+r)))/2
  temp_name1 gt
  temp_expr1 (g+sqrt(g*(4*fl+g)))/2
  temp_name2 bt
  temp_expr2 (b+sqrt(b*(4*fl+b)))/2
  expr0 (pow(rt/sy,1/p)/(1-pow(rt/sy,1/p)))*sx
  expr1 (pow(gt/sy,1/p)/(1-pow(gt/sy,1/p)))*sx
  expr2 (pow(bt/sy,1/p)/(1-pow(bt/sy,1/p)))*sx
  name InvToneScale
  xpos 180
  ypos 14
  addUserKnob {20 Params}
  addUserKnob {7 Lw R 100 4000}
  Lw {{parent.ToneScale.Lw}}
  addUserKnob {7 p R 1 2}
  p {{parent.ToneScale.p}}
  addUserKnob {7 fl l flare R 0 0.01}
  fl {{parent.ToneScale.fl}}
  addUserKnob {7 sx R 0 10}
  sx {{parent.ToneScale.sx}}
  addUserKnob {7 sy R 0 4}
  sy {{parent.ToneScale.sy}}
 }
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  name rgbDT_to_XYZ1
  xpos 180
  ypos 63
 }
 ColorMatrix {
  matrix {
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
    }
  invert true
  name XYZ_to_InGamut
  xpos 180
  ypos 111
 }
push $N30956000
 Group {
  name InGamut_to_XYZ
  tile_color 0x429940ff
  xpos -40
  ypos -154
  addUserKnob {20 InputGamut_to_XYZ_tab l InputGamut_to_XYZ}
  addUserKnob {4 gamut l "input gamut" M {ACES ACEScg P3D65 Rec.2020 Rec.709 "Alexa WideGamut" "Red WideGamutRGB" "Sony SGamut3" "Filmlight E-Gamut" "DaVinci Wide Gamut" "" ""}}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -610
  }
  Dot {
   name Dot1
   xpos 324
   ypos -546
  }
set N308c5c00 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -370
  }
  Output {
   name Output
   xpos 290
   ypos -250
  }
push $N308c5c00
  Dot {
   name Dot391
   label " *RGB to XYZ D65 CAT: XYZ Scaling"
   xpos 434
   ypos -546
  }
set N308c5000 [stack 0]
  ColorMatrix {
   matrix {
       {0.7006223202 0.1487748027 0.101058729}
       {0.2741184831 0.8736317754 -0.1477504224}
       {-0.09896290302 -0.1378953159 1.325916052}
     }
   name ColorMatrix30
   label "DaVinci WG to XYZ D65"
   xpos 1390
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.705396831 0.1640413404 0.08101775497}
       {0.2801307142 0.8202067018 -0.1003373787}
       {-0.1037815139 -0.07290726155 1.265746593}
     }
   name ColorMatrix29
   label "Filmlight E-Gamut to XYZ D65"
   xpos 1280
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.5990839005 0.2489254922 0.1024464965}
       {0.2150758207 0.8850684166 -0.1001443192}
       {-0.03206584975 -0.02765838802 1.148782015}
     }
   name ColorMatrix31
   label "SonySGamut3 to XYZ D65"
   xpos 1170
   ypos -465
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.735275209 0.06860940903 0.1465712786}
       {0.2866940796 0.8429790735 -0.1296732426}
       {-0.07968084514 -0.3473432064 1.516081929}
     }
   name ColorMatrix22
   label "REDWideGamutRGB to XYZ D65"
   xpos 1060
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.6380076408 0.2147038132 0.09774445742}
       {0.2919537723 0.8238408566 -0.1157948226}
       {0.002798279049 -0.06703422219 1.153293848}
     }
   name ColorMatrix21
   label "Arri AlexaWideGamut to XYZ D65"
   xpos 950
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.4123909175 0.3575843573 0.1804807931}
       {0.2126390785 0.7151687145 0.07219231129}
       {0.01933082566 0.1191947833 0.9505321383}
     }
   name ColorMatrix18
   label "Rec709 to XYZ D65"
   xpos 840
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.6369581223 0.1446169168 0.1688809693}
       {0.2627002299 0.6779981256 0.05930171534}
       {4.99410725e-17 0.02807269618 1.060985088}
     }
   name ColorMatrix17
   label "Rec2020 to XYZ D65"
   xpos 730
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.4865711331 0.2656677067 0.1982173175}
       {0.2289746404 0.6917386055 0.07928691804}
       {-3.972076965e-17 0.04511338845 1.043944478}
     }
   name ColorMatrix16
   label "P3D65 to XYZ D65"
   xpos 620
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.6609312296 0.1336961389 0.1558285803}
       {0.2722287476 0.6740817428 0.05368950963}
       {-0.006018006243 0.004383686464 1.090692043}
     }
   name ColorMatrix1
   label "ACEScg to XYZ D65"
   xpos 510
   ypos -466
  }
push $N308c5000
  ColorMatrix {
   matrix {
       {0.9503623843 0 9.346324805e-05}
       {0.3439664543 0.728166163 -0.07213254273}
       {0 0 1.089057803}
     }
   name ColorMatrix2
   label "ACES to XYZ D65"
   xpos 400
   ypos -466
  }
  Switch {
   inputs 10
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -370
  }
 end_group
set N308cab00 [stack 0]
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  invert true
  name XYZ_to_rgbDT
  xpos -40
  ypos -130
 }
set N3085e000 [stack 0]
 BlinkScript {
  kernelSourceFile "/Volumes/GoogleDrive/My Drive/nuke/blink/mmTonescale.blink"
  recompileCount 261
  ProgramGroup 1
  KernelDescription "2 \"mmTonescaleKernel\" iterate pixelWise 6d1fd726714ba576f27ad0e2552788cdf5fce5ac24ed2a7700c2ea20a005911c 2 \"src\" Read Point \"dst\" Write Point 16 \"inverse\" Bool 1 AA== \"Lp\" Float 1 AAAAAA== \"su\" Float 1 AAAAAA== \"c0\" Float 1 AAAAAA== \"cs\" Float 1 AAAAAA== \"c1\" Float 1 AAAAAA== \"p\" Float 1 AAAAAA== \"w1\" Float 1 AAAAAA== \"s1\" Float 1 AAAAAA== \"ex\" Float 1 AAAAAA== \"eb\" Float 1 AAAAAA== \"e0\" Float 1 AAAAAA== \"s0\" Float 1 AAAAAA== \"fl\" Float 1 AAAAAA== \"dch\" Float 1 AAAAAA== \"sat\" Float 1 AAAAAA== 16 \"inverse\" 1 1 \"Lp\" 1 1 \"su\" 1 1 \"c0\" 1 1 \"cs\" 1 1 \"c1\" 1 1 \"p\" 1 1 \"w1\" 1 1 \"s1\" 1 1 \"ex\" 1 1 \"eb\" 1 1 \"e0\" 1 1 \"s0\" 1 1 \"fl\" 1 1 \"dch\" 1 1 \"sat\" 1 1 0"
  kernelSource "\nkernel mmTonescaleKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n   \n\n    // Tonescale select\n    bool inverse;\n    // OpenDRT tonescale parameters\n    float Lp;\n    float su;\n    float c0;\n    float cs;\n    float c1;\n    float p;\n    float w1;\n    float s1;\n    float ex;\n    float eb;\n    float e0;\n    float s0;\n    float fl;\n    float dch;\n    float sat;\n\n  local:\n\n    // constants\n  void define()\n  \{\n\n  \}\n\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n\n  float forwardMmTonescale(float x)\n  \{\n      float tc = 0.0f;\n      if (x<0.18)\n      \{\n          tc = cs*spow(x,c0);\n      \}\n      else\n      \{\n          tc = c0*(x-0.18)+0.18;\n      \}\n      \n      float ts = s1*spow((tc/(s0+tc)),p);\n      float tf = ts*ts/(ts+fl);\n      float ccf = spow(s0/(x+s0),dch)*sat;\n\n      return tf;\n  \}\n\n  float inverseMmTonescale(float x)\n  \{\n\n      float tf = (x+sqrt(x*(4*fl+x)))/2;\n      float ts = s0/(spow((s1/tf),(1/p))-1);\n      float tc = 0.0f;\n      if (ts<0.18)\n      \{\n          tc = spow((ts/cs),(1/c0));\n      \}\n      else\n      \{\n          tc = (ts-0.18)/c0+0.18;\n      \}\n      float ccf = spow(s0/(tc+s0),dch)*sat;\n\n      return tc;\n  \}\n\n\n  void init()\n  \{\n    \n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 mappedVals;\n    if(!inverse)\n    \{\n        mappedVals.x = forwardMmTonescale(source.x);\n        mappedVals.y = forwardMmTonescale(source.y);\n        mappedVals.z = forwardMmTonescale(source.z);\n    \}\n    else\n    \{\n        mappedVals.x = inverseMmTonescale(source.x);\n        mappedVals.y = inverseMmTonescale(source.y);\n        mappedVals.z = inverseMmTonescale(source.z);\n    \}\n\n\n    float3 dstRGB;\n\n    dst() = float4(mappedVals.x, mappedVals.y, mappedVals.z, source.w); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  mmTonescaleKernel_Lp 100
  mmTonescaleKernel_su 2
  mmTonescaleKernel_c0 1.2
  mmTonescaleKernel_cs {{0.18**(1-mmTonescaleKernel_c0)}}
  mmTonescaleKernel_c1 1.1
  mmTonescaleKernel_p {{mmTonescaleKernel_c1*(0.9+0.05*mmTonescaleKernel_su)}}
  mmTonescaleKernel_w1 {{(0.595*mmTonescaleKernel_Lp/10000)**0.931+1.037}}
  mmTonescaleKernel_s1 {{mmTonescaleKernel_w1*mmTonescaleKernel_Lp/100}}
  mmTonescaleKernel_ex -0.26
  mmTonescaleKernel_eb 0.08
  mmTonescaleKernel_e0 {{2**(mmTonescaleKernel_ex+mmTonescaleKernel_eb*log(mmTonescaleKernel_s1)/log(2))}}
  mmTonescaleKernel_s0 {{(mmTonescaleKernel_s1/mmTonescaleKernel_e0)**(1/mmTonescaleKernel_c1)}}
  mmTonescaleKernel_fl 0.01
  mmTonescaleKernel_dch 0.55
  mmTonescaleKernel_sat {{max(1,1.125-0.00025*mmTonescaleKernel_Lp)}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -132
  ypos -67
 }
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  name rgbDT_to_XYZ
  xpos -40
  ypos 2
 }
set N3085d800 [stack 0]
 Group {
  name XYZ_to_DisplayGamut
  tile_color 0x425440ff
  xpos -40
  ypos 26
  addUserKnob {20 XYZ_to_DisplayGamut_tab l XYZ_to_DisplayGamut}
  addUserKnob {4 gamut l "display gamut" t "Choose the target display device chromaticities." M {Rec.2020 "P3 D65" "P3 D60" "P3 DCI" Rec.709 "DCDM X'Y'Z'"}}
  gamut Rec.709
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -580
  }
  Dot {
   name Dot391
   label " "
   xpos 324
   ypos -516
  }
set N3085d000 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -399
  }
  Output {
   name Output
   xpos 290
   ypos -310
  }
push $N3085d000
  Dot {
   name Dot1
   label " XYZ D65 to *RGB CAT: XYZ Scaling"
   xpos 434
   ypos -516
  }
set N3085c400 [stack 0]
  ColorMatrix {
   matrix {
       {1 0 0}
       {0 1 0}
       {0 0 1}
     }
   name ColorMatrix4
   label "XYZ D65 to XYZ E"
   xpos 950
   ypos -465
  }
push $N3085c400
  ColorMatrix {
   matrix {
       {3.240968943 -1.537382722 -0.4986106157}
       {-0.9692435861 1.875967264 0.04155508429}
       {0.05563007668 -0.2039769441 1.056971431}
     }
   name ColorMatrix2
   label "XYZ D65 to Rec709"
   xpos 840
   ypos -465
  }
push $N3085c400
  ColorMatrix {
   matrix {
       {2.72539258 -1.01800251 -0.4401629865}
       {-0.795167923 1.689731836 0.02264717408}
       {0.04124189168 -0.08763902634 1.100929379}
     }
   name ColorMatrix12
   label "XYZ D65 to P3DCI"
   xpos 730
   ypos -465
  }
push $N3085c400
  ColorMatrix {
   matrix {
       {2.40274024 -0.8974836469 -0.3880532086}
       {-0.8325793743 1.769231319 0.02371269651}
       {0.03882337734 -0.0824996829 1.036368608}
     }
   name ColorMatrix11
   label "XYZ D65 to P3D60"
   xpos 620
   ypos -465
  }
push $N3085c400
  ColorMatrix {
   matrix {
       {2.493495464 -0.9313831329 -0.4027105868}
       {-0.8294886947 1.762663484 0.02362468652}
       {0.03584581986 -0.07617236674 0.9568843246}
     }
   name ColorMatrix10
   label "XYZ D65 to P3D65"
   xpos 510
   ypos -465
  }
push $N3085c400
  ColorMatrix {
   matrix {
       {1.716650844 -0.3556707203 -0.2533662021}
       {-0.6666842103 1.616480947 0.01576854289}
       {0.01763985492 -0.04277061298 0.9421030283}
     }
   name ColorMatrix5
   label "XYZ D65 to Rec2020"
   xpos 400
   ypos -465
  }
  Switch {
   inputs 6
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -399
  }
 end_group
 ColorMatrix {
  matrix {
      {{"(1.0 - sat) * rgb2Y.x + sat"} {"(1.0 - sat) * rgb2Y.y"} {"(1.0 - sat) * rgb2Y.z"}}
      {{"(1.0 - sat) * rgb2Y.x"} {"(1.0 - sat) * rgb2Y.y + sat"} {"(1.0 - sat) * rgb2Y.z"}}
      {{"(1.0 - sat) * rgb2Y.x"} {"(1.0 - sat) * rgb2Y.y"} {"(1.0 - sat) * rgb2Y.z + sat"}}
    }
  name Saturation
  selected true
  xpos -40
  ypos 50
  addUserKnob {20 params}
  addUserKnob {13 rgb2Y}
  rgb2Y {0.21263911 0.71516877 0.07219233}
  addUserKnob {7 sat}
  sat 0.9
 }
 Multiply {
  channels rgb
  value {{tint/n} {tint/n} {tint/n} 1}
  name Tint
  xpos -40
  ypos 87
  addUserKnob {20 Params}
  addUserKnob {18 tint R 0.8 1.2}
  tint 1
  addUserKnob {6 tint_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 n R 0 4}
  n {{max(0.001,max(tint.r,tint.g,tint.b))}}
 }
 Expression {
  temp_name0 mx
  temp_expr0 dcdm?1:sc
  expr0 parent.clamp?max(0,min(mx,r*sc)):r*sc
  expr1 parent.clamp?max(0,min(mx,g*sc)):g*sc
  expr2 parent.clamp?max(0,min(mx,b*sc)):b*sc
  name DisplayScale
  xpos -40
  ypos 111
  addUserKnob {20 Params}
  addUserKnob {6 pq +STARTLINE}
  pq {{eotf==4}}
  addUserKnob {6 hlg -STARTLINE}
  hlg {{eotf==5}}
  addUserKnob {6 dcdm -STARTLINE}
  dcdm {{eotf==3&&display_gamut==5}}
  addUserKnob {7 sc}
  sc {{pq?Lw/10000:hlg?Lw/1000:dcdm?48/52.37:1}}
 }
 Group {
  name InverseEOTF
  xpos -40
  ypos 158
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG "" "" ""}}
  eotf BT.1886
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -160
  }
  Dot {
   name Dot1
   xpos 434
   ypos -96
  }
set N307ed400 [stack 0]
  Dot {
   name Dot3
   xpos 544
   ypos -96
  }
set N307ed000 [stack 0]
  Dot {
   name Dot4
   xpos 654
   ypos -96
  }
  Expression {
   temp_name0 Yd
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 r*pow(Yd,(1-_g)/_g)
   expr1 g*pow(Yd,(1-_g)/_g)
   expr2 b*pow(Yd,(1-_g)/_g)
   name HLG_InverseOOTF
   xpos 620
   ypos -70
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lw/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lw R 600 4000}
   Lw {{parent.parent.Lw}}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
  Expression {
   expr0 r<=1/12?sqrt(3*r):_a*log(12*r-_b)+_c
   expr1 g<=1/12?sqrt(3*g):_a*log(12*g-_b)+_c
   expr2 b<=1/12?sqrt(3*b):_a*log(12*b-_b)+_c
   name HLG_OETF
   xpos 620
   ypos -38
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
push $N307ed000
  Expression {
   expr0 pow((c_1+c_2*pow(r*Lw/10000,m_1))/(1+c_3*pow(r*Lw/10000,m_1)),m_2)
   expr1 pow((c_1+c_2*pow(g*Lw/10000,m_1))/(1+c_3*pow(g*Lw/10000,m_1)),m_2)
   expr2 pow((c_1+c_2*pow(b*Lw/10000,m_1))/(1+c_3*pow(b*Lw/10000,m_1)),m_2)
   name ST2084_InverseEOTF
   xpos 510
   ypos -70
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
   addUserKnob {7 Lw t "Display peak luminance in nits" R 600 4000}
   Lw 10000
  }
push $N307ed400
  Expression {
   expr0 sign(r)*pow(fabs(r),1/p)
   expr1 sign(g)*pow(fabs(g),1/p)
   expr2 sign(b)*pow(fabs(b),1/p)
   name power
   selected true
   xpos 400
   ypos -70
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos -10
  }
  Output {
   name Output
   xpos 400
   ypos 50
  }
 end_group
 Switch {
  inputs 2
  which {{parent.direction}}
  name SwitchDirection
  xpos -40
  ypos 230
 }
 Output {
  name Output
  xpos -40
  ypos 302
 }
 StickyNote {
  inputs 0
  name StickyNote1
  tile_color 0x272727ff
  label "<left><pre>\n<b>\"rgbDT\" render gamut</b>\nrxy 0.859 0.264\ngxy 0.137 1.12\nbxy 0.085 -0.096\nwxy 0.3127 0.329"
  note_font "Nimbus Sans \[UKWN]"
  note_font_color 0xa8a8a8ff
  xpos -244
  ypos -171
 }
push $N3085e000
 Expression {
  temp_name0 rs
  temp_expr0 sy*pow(r/(r+sx),p)
  temp_name1 gs
  temp_expr1 sy*pow(g/(g+sx),p)
  temp_name2 bs
  temp_expr2 sy*pow(b/(b+sx),p)
  expr0 rs*rs/(rs+fl)
  expr1 gs*gs/(gs+fl)
  expr2 bs*bs/(bs+fl)
  name ToneScale
  xpos -11
  ypos -56
  addUserKnob {20 Params}
  addUserKnob {7 Lw R 100 4000}
  Lw 100
  addUserKnob {7 c l contrast R 0.8 2}
  c {{12*pow(Lw,-0.86)+1.17}}
  addUserKnob {4 su l surround t "dark = 1.0\ndim = 0.95\naverage = 0.90" M {average dim dark}}
  su dim
  addUserKnob {7 p R 1 2}
  p {{c*(0.9+0.05*su)}}
  addUserKnob {7 fl l flare R 0 0.01}
  fl {{1/Lw}}
  addUserKnob {7 sx R 0 10}
  sx {{0.016*pow(Lw,0.87)-0.17}}
  addUserKnob {7 sy R 0 4}
  sy {{1.036+5e-5*Lw}}
 }
push $N3085d800
push $N308cab00
 Viewer {
  inputs 2
  frame_range 1-112
  gl_buffer_depth half-float
  name Viewer1
  xpos -167
  ypos 2
 }
end_group
set N30598800 [stack 0]
Group {
 name SDR_to_HDR2
 xpos 99
 ypos 437
}
 Input {
  inputs 0
  name Input1
  xpos 692
  ypos -182
 }
 Colorspace {
  colorspace_in 2.40
  primary_out Rec.2020
  name Colorspace1
  xpos 692
  ypos -142
 }
 Multiply {
  value 100
  name Multiply1
  xpos 692
  ypos -118
 }
 Colorspace {
  colorspace_out st2084
  name Colorspace2
  selected true
  xpos 692
  ypos -86
 }
 Output {
  name Output1
  xpos 692
  ypos 14
 }
end_group
Group {
 name Write_ResolveACES_ODT_LUT10
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 99
 ypos 461
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate A
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (Rec709 sim)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateA rev008 Rec2100 (Rec709 sim).cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N44f6dc00
Group {
 name rgbDT1
 label "MM\nRec2020 PQ"
 xpos 207
 ypos 352
 addUserKnob {20 Params}
 addUserKnob {41 gamut l "input gamut" T InGamut_to_XYZ.gamut}
 addUserKnob {41 Lw T ToneScale.Lw}
 addUserKnob {41 su l surround T ToneScale.su}
 addUserKnob {41 tint T Tint.tint}
 addUserKnob {26 ""}
 addUserKnob {41 eotf T InverseEOTF.eotf}
 addUserKnob {41 display_gamut l "display gamut" -STARTLINE T XYZ_to_DisplayGamut.gamut}
 addUserKnob {6 clamp -STARTLINE}
 clamp true
 addUserKnob {4 direction M {forward inverse}}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos -226
 }
set N46866000 [stack 0]
 Group {
  name EOTF
  xpos 180
  ypos -154
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf l EOTF t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG ""}}
  eotf {{parent.InverseEOTF.eotf}}
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -130
  }
set N46865c00 [stack 0]
  Expression {
   expr0 r<=0.5?r*r/3:(exp((r-_c)/_a)+_b)/12
   expr1 g<=0.5?g*g/3:(exp((g-_c)/_a)+_b)/12
   expr2 b<=0.5?b*b/3:(exp((b-_c)/_a)+_b)/12
   name HLG_InverseOETF
   xpos 620
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
  Expression {
   temp_name0 Ys
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 pow(Ys,_g-1)*r
   expr1 pow(Ys,_g-1)*g
   expr2 pow(Ys,_g-1)*b
   name HLG_OOTF
   xpos 620
   ypos -34
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lw/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lw R 600 4000}
   Lw 1000
   addUserKnob {7 Lb}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
push $N46865c00
  Expression {
   temp_name0 rp
   temp_expr0 pow(r,1/m_2)
   temp_name1 gp
   temp_expr1 pow(g,1/m_2)
   temp_name2 bp
   temp_expr2 pow(b,1/m_2)
   expr0 pow((rp-c_1)/(c_2-c_3*rp),1/m_1)
   expr1 pow((gp-c_1)/(c_2-c_3*gp),1/m_1)
   expr2 pow((bp-c_1)/(c_2-c_3*bp),1/m_1)
   name ST2084_EOTF
   xpos 510
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
  }
push $N46865c00
  Expression {
   expr0 sign(r)*pow(fabs(r),p)
   expr1 sign(g)*pow(fabs(g),p)
   expr2 sign(b)*pow(fabs(b),p)
   name Power
   xpos 400
   ypos -58
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos -10
  }
  Output {
   name Output
   xpos 400
   ypos 62
  }
 end_group
 Expression {
  expr0 r*sc
  expr1 g*sc
  expr2 b*sc
  name InvDisplayScale
  xpos 180
  ypos -130
  addUserKnob {20 Params}
  addUserKnob {7 sc}
  sc {{parent.DisplayScale.sc}}
 }
 Multiply {
  channels rgb
  value {{1/parent.Tint.value} {1/parent.Tint.value} {1/parent.Tint.value} 1}
  name InvTint
  xpos 180
  ypos -105
 }
 ColorMatrix {
  matrix {
      {{parent.Saturation.matrix} {parent.Saturation.matrix} {parent.Saturation.matrix}}
      {{parent.Saturation.matrix} {parent.Saturation.matrix} {parent.Saturation.matrix}}
      {{parent.Saturation.matrix} {parent.Saturation.matrix} {parent.Saturation.matrix}}
    }
  invert true
  name InvSaturation
  xpos 180
  ypos -81
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
    }
  invert true
  name DisplayGamut_to_XYZ
  xpos 180
  ypos -57
 }
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  invert true
  name XYZ_to_rgbDT1
  xpos 180
  ypos -33
 }
 Expression {
  temp_name0 rt
  temp_expr0 (r+sqrt(r*(4*fl+r)))/2
  temp_name1 gt
  temp_expr1 (g+sqrt(g*(4*fl+g)))/2
  temp_name2 bt
  temp_expr2 (b+sqrt(b*(4*fl+b)))/2
  expr0 (pow(rt/sy,1/p)/(1-pow(rt/sy,1/p)))*sx
  expr1 (pow(gt/sy,1/p)/(1-pow(gt/sy,1/p)))*sx
  expr2 (pow(bt/sy,1/p)/(1-pow(bt/sy,1/p)))*sx
  name InvToneScale
  xpos 180
  ypos 14
  addUserKnob {20 Params}
  addUserKnob {7 Lw R 100 4000}
  Lw {{parent.ToneScale.Lw}}
  addUserKnob {7 p R 1 2}
  p {{parent.ToneScale.p}}
  addUserKnob {7 fl l flare R 0 0.01}
  fl {{parent.ToneScale.fl}}
  addUserKnob {7 sx R 0 10}
  sx {{parent.ToneScale.sx}}
  addUserKnob {7 sy R 0 4}
  sy {{parent.ToneScale.sy}}
 }
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  name rgbDT_to_XYZ1
  xpos 180
  ypos 63
 }
 ColorMatrix {
  matrix {
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
    }
  invert true
  name XYZ_to_InGamut
  xpos 180
  ypos 111
 }
push $N46866000
 Group {
  name InGamut_to_XYZ
  tile_color 0x429940ff
  xpos -40
  ypos -154
  addUserKnob {20 InputGamut_to_XYZ_tab l InputGamut_to_XYZ}
  addUserKnob {4 gamut l "input gamut" M {ACES ACEScg P3D65 Rec.2020 Rec.709 "Alexa WideGamut" "Red WideGamutRGB" "Sony SGamut3" "Filmlight E-Gamut" "DaVinci Wide Gamut" "" ""}}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -610
  }
  Dot {
   name Dot1
   xpos 324
   ypos -546
  }
set N74705c00 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -370
  }
  Output {
   name Output
   xpos 290
   ypos -250
  }
push $N74705c00
  Dot {
   name Dot391
   label " *RGB to XYZ D65 CAT: XYZ Scaling"
   xpos 434
   ypos -546
  }
set N74705000 [stack 0]
  ColorMatrix {
   matrix {
       {0.7006223202 0.1487748027 0.101058729}
       {0.2741184831 0.8736317754 -0.1477504224}
       {-0.09896290302 -0.1378953159 1.325916052}
     }
   name ColorMatrix30
   label "DaVinci WG to XYZ D65"
   xpos 1390
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.705396831 0.1640413404 0.08101775497}
       {0.2801307142 0.8202067018 -0.1003373787}
       {-0.1037815139 -0.07290726155 1.265746593}
     }
   name ColorMatrix29
   label "Filmlight E-Gamut to XYZ D65"
   xpos 1280
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.5990839005 0.2489254922 0.1024464965}
       {0.2150758207 0.8850684166 -0.1001443192}
       {-0.03206584975 -0.02765838802 1.148782015}
     }
   name ColorMatrix31
   label "SonySGamut3 to XYZ D65"
   xpos 1170
   ypos -465
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.735275209 0.06860940903 0.1465712786}
       {0.2866940796 0.8429790735 -0.1296732426}
       {-0.07968084514 -0.3473432064 1.516081929}
     }
   name ColorMatrix22
   label "REDWideGamutRGB to XYZ D65"
   xpos 1060
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.6380076408 0.2147038132 0.09774445742}
       {0.2919537723 0.8238408566 -0.1157948226}
       {0.002798279049 -0.06703422219 1.153293848}
     }
   name ColorMatrix21
   label "Arri AlexaWideGamut to XYZ D65"
   xpos 950
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.4123909175 0.3575843573 0.1804807931}
       {0.2126390785 0.7151687145 0.07219231129}
       {0.01933082566 0.1191947833 0.9505321383}
     }
   name ColorMatrix18
   label "Rec709 to XYZ D65"
   xpos 840
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.6369581223 0.1446169168 0.1688809693}
       {0.2627002299 0.6779981256 0.05930171534}
       {4.99410725e-17 0.02807269618 1.060985088}
     }
   name ColorMatrix17
   label "Rec2020 to XYZ D65"
   xpos 730
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.4865711331 0.2656677067 0.1982173175}
       {0.2289746404 0.6917386055 0.07928691804}
       {-3.972076965e-17 0.04511338845 1.043944478}
     }
   name ColorMatrix16
   label "P3D65 to XYZ D65"
   xpos 620
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.6609312296 0.1336961389 0.1558285803}
       {0.2722287476 0.6740817428 0.05368950963}
       {-0.006018006243 0.004383686464 1.090692043}
     }
   name ColorMatrix1
   label "ACEScg to XYZ D65"
   xpos 510
   ypos -466
  }
push $N74705000
  ColorMatrix {
   matrix {
       {0.9503623843 0 9.346324805e-05}
       {0.3439664543 0.728166163 -0.07213254273}
       {0 0 1.089057803}
     }
   name ColorMatrix2
   label "ACES to XYZ D65"
   xpos 400
   ypos -466
  }
  Switch {
   inputs 10
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -370
  }
 end_group
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  invert true
  name XYZ_to_rgbDT
  xpos -40
  ypos -130
 }
set N30636000 [stack 0]
 BlinkScript {
  kernelSourceFile "/Volumes/GoogleDrive/My Drive/nuke/blink/mmTonescale.blink"
  recompileCount 261
  ProgramGroup 1
  KernelDescription "2 \"mmTonescaleKernel\" iterate pixelWise 6d1fd726714ba576f27ad0e2552788cdf5fce5ac24ed2a7700c2ea20a005911c 2 \"src\" Read Point \"dst\" Write Point 16 \"inverse\" Bool 1 AA== \"Lp\" Float 1 AAAAAA== \"su\" Float 1 AAAAAA== \"c0\" Float 1 AAAAAA== \"cs\" Float 1 AAAAAA== \"c1\" Float 1 AAAAAA== \"p\" Float 1 AAAAAA== \"w1\" Float 1 AAAAAA== \"s1\" Float 1 AAAAAA== \"ex\" Float 1 AAAAAA== \"eb\" Float 1 AAAAAA== \"e0\" Float 1 AAAAAA== \"s0\" Float 1 AAAAAA== \"fl\" Float 1 AAAAAA== \"dch\" Float 1 AAAAAA== \"sat\" Float 1 AAAAAA== 16 \"inverse\" 1 1 \"Lp\" 1 1 \"su\" 1 1 \"c0\" 1 1 \"cs\" 1 1 \"c1\" 1 1 \"p\" 1 1 \"w1\" 1 1 \"s1\" 1 1 \"ex\" 1 1 \"eb\" 1 1 \"e0\" 1 1 \"s0\" 1 1 \"fl\" 1 1 \"dch\" 1 1 \"sat\" 1 1 0"
  kernelSource "\nkernel mmTonescaleKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n   \n\n    // Tonescale select\n    bool inverse;\n    // OpenDRT tonescale parameters\n    float Lp;\n    float su;\n    float c0;\n    float cs;\n    float c1;\n    float p;\n    float w1;\n    float s1;\n    float ex;\n    float eb;\n    float e0;\n    float s0;\n    float fl;\n    float dch;\n    float sat;\n\n  local:\n\n    // constants\n  void define()\n  \{\n\n  \}\n\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n\n  float forwardMmTonescale(float x)\n  \{\n      float tc = 0.0f;\n      if (x<0.18)\n      \{\n          tc = cs*spow(x,c0);\n      \}\n      else\n      \{\n          tc = c0*(x-0.18)+0.18;\n      \}\n      \n      float ts = s1*spow((tc/(s0+tc)),p);\n      float tf = ts*ts/(ts+fl);\n      float ccf = spow(s0/(x+s0),dch)*sat;\n\n      return tf;\n  \}\n\n  float inverseMmTonescale(float x)\n  \{\n\n      float tf = (x+sqrt(x*(4*fl+x)))/2;\n      float ts = s0/(spow((s1/tf),(1/p))-1);\n      float tc = 0.0f;\n      if (ts<0.18)\n      \{\n          tc = spow((ts/cs),(1/c0));\n      \}\n      else\n      \{\n          tc = (ts-0.18)/c0+0.18;\n      \}\n      float ccf = spow(s0/(tc+s0),dch)*sat;\n\n      return tc;\n  \}\n\n\n  void init()\n  \{\n    \n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 mappedVals;\n    if(!inverse)\n    \{\n        mappedVals.x = forwardMmTonescale(source.x);\n        mappedVals.y = forwardMmTonescale(source.y);\n        mappedVals.z = forwardMmTonescale(source.z);\n    \}\n    else\n    \{\n        mappedVals.x = inverseMmTonescale(source.x);\n        mappedVals.y = inverseMmTonescale(source.y);\n        mappedVals.z = inverseMmTonescale(source.z);\n    \}\n\n\n    float3 dstRGB;\n\n    dst() = float4(mappedVals.x, mappedVals.y, mappedVals.z, source.w); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  mmTonescaleKernel_Lp {{parent.Lw}}
  mmTonescaleKernel_su 2
  mmTonescaleKernel_c0 1.2
  mmTonescaleKernel_cs {{0.18**(1-mmTonescaleKernel_c0)}}
  mmTonescaleKernel_c1 1.1
  mmTonescaleKernel_p {{mmTonescaleKernel_c1*(0.9+0.05*mmTonescaleKernel_su)}}
  mmTonescaleKernel_w1 {{(0.595*mmTonescaleKernel_Lp/10000)**0.931+1.037}}
  mmTonescaleKernel_s1 {{mmTonescaleKernel_w1*mmTonescaleKernel_Lp/100}}
  mmTonescaleKernel_ex -0.26
  mmTonescaleKernel_eb 0.08
  mmTonescaleKernel_e0 {{2**(mmTonescaleKernel_ex+mmTonescaleKernel_eb*log(mmTonescaleKernel_s1)/log(2))}}
  mmTonescaleKernel_s0 {{(mmTonescaleKernel_s1/mmTonescaleKernel_e0)**(1/mmTonescaleKernel_c1)}}
  mmTonescaleKernel_fl 0.01
  mmTonescaleKernel_dch 0.55
  mmTonescaleKernel_sat {{max(1,1.125-0.00025*mmTonescaleKernel_Lp)}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -141
  ypos -67
 }
 Multiply {
  value 0.1
  name Multiply1
  selected true
  xpos -141
  ypos -31
 }
 ColorMatrix {
  matrix {
      {0.7211384177 0.1114893705 0.1178281307}
      {0.2216304243 0.9114459753 -0.1330764741}
      {-0.1032596305 -0.2091442943 1.40146172}
    }
  name rgbDT_to_XYZ
  xpos -40
  ypos 2
 }
set N30635800 [stack 0]
 Group {
  name XYZ_to_DisplayGamut
  tile_color 0x425440ff
  xpos -40
  ypos 26
  addUserKnob {20 XYZ_to_DisplayGamut_tab l XYZ_to_DisplayGamut}
  addUserKnob {4 gamut l "display gamut" t "Choose the target display device chromaticities." M {Rec.2020 "P3 D65" "P3 D60" "P3 DCI" Rec.709 "DCDM X'Y'Z'"}}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -580
  }
  Dot {
   name Dot391
   label " "
   xpos 324
   ypos -516
  }
set N30635000 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -399
  }
  Output {
   name Output
   xpos 290
   ypos -310
  }
push $N30635000
  Dot {
   name Dot1
   label " XYZ D65 to *RGB CAT: XYZ Scaling"
   xpos 434
   ypos -516
  }
set N30634400 [stack 0]
  ColorMatrix {
   matrix {
       {1 0 0}
       {0 1 0}
       {0 0 1}
     }
   name ColorMatrix4
   label "XYZ D65 to XYZ E"
   xpos 950
   ypos -465
  }
push $N30634400
  ColorMatrix {
   matrix {
       {3.240968943 -1.537382722 -0.4986106157}
       {-0.9692435861 1.875967264 0.04155508429}
       {0.05563007668 -0.2039769441 1.056971431}
     }
   name ColorMatrix2
   label "XYZ D65 to Rec709"
   xpos 840
   ypos -465
  }
push $N30634400
  ColorMatrix {
   matrix {
       {2.72539258 -1.01800251 -0.4401629865}
       {-0.795167923 1.689731836 0.02264717408}
       {0.04124189168 -0.08763902634 1.100929379}
     }
   name ColorMatrix12
   label "XYZ D65 to P3DCI"
   xpos 730
   ypos -465
  }
push $N30634400
  ColorMatrix {
   matrix {
       {2.40274024 -0.8974836469 -0.3880532086}
       {-0.8325793743 1.769231319 0.02371269651}
       {0.03882337734 -0.0824996829 1.036368608}
     }
   name ColorMatrix11
   label "XYZ D65 to P3D60"
   xpos 620
   ypos -465
  }
push $N30634400
  ColorMatrix {
   matrix {
       {2.493495464 -0.9313831329 -0.4027105868}
       {-0.8294886947 1.762663484 0.02362468652}
       {0.03584581986 -0.07617236674 0.9568843246}
     }
   name ColorMatrix10
   label "XYZ D65 to P3D65"
   xpos 510
   ypos -465
  }
push $N30634400
  ColorMatrix {
   matrix {
       {1.716650844 -0.3556707203 -0.2533662021}
       {-0.6666842103 1.616480947 0.01576854289}
       {0.01763985492 -0.04277061298 0.9421030283}
     }
   name ColorMatrix5
   label "XYZ D65 to Rec2020"
   xpos 400
   ypos -465
  }
  Switch {
   inputs 6
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -399
  }
 end_group
 ColorMatrix {
  matrix {
      {{"(1.0 - sat) * rgb2Y.x + sat"} {"(1.0 - sat) * rgb2Y.y"} {"(1.0 - sat) * rgb2Y.z"}}
      {{"(1.0 - sat) * rgb2Y.x"} {"(1.0 - sat) * rgb2Y.y + sat"} {"(1.0 - sat) * rgb2Y.z"}}
      {{"(1.0 - sat) * rgb2Y.x"} {"(1.0 - sat) * rgb2Y.y"} {"(1.0 - sat) * rgb2Y.z + sat"}}
    }
  name Saturation
  xpos -40
  ypos 50
  addUserKnob {20 params}
  addUserKnob {13 rgb2Y}
  rgb2Y {0.21263911 0.71516877 0.07219233}
  addUserKnob {7 sat}
  sat 0.9
 }
 Multiply {
  channels rgb
  value {{tint/n} {tint/n} {tint/n} 1}
  name Tint
  xpos -40
  ypos 87
  addUserKnob {20 Params}
  addUserKnob {18 tint R 0.8 1.2}
  tint 1
  addUserKnob {6 tint_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 n R 0 4}
  n {{max(0.001,max(tint.r,tint.g,tint.b))}}
 }
 Expression {
  temp_name0 mx
  temp_expr0 dcdm?1:sc
  expr0 parent.clamp?max(0,min(mx,r*sc)):r*sc
  expr1 parent.clamp?max(0,min(mx,g*sc)):g*sc
  expr2 parent.clamp?max(0,min(mx,b*sc)):b*sc
  name DisplayScale
  xpos -40
  ypos 122
  addUserKnob {20 Params}
  addUserKnob {6 pq +STARTLINE}
  pq {{eotf==4}}
  addUserKnob {6 hlg -STARTLINE}
  hlg {{eotf==5}}
  addUserKnob {6 dcdm -STARTLINE}
  dcdm {{eotf==3&&display_gamut==5}}
  addUserKnob {7 sc}
  sc {{pq?Lw/10000:hlg?Lw/1000:dcdm?48/52.37:1}}
 }
set N305c1c00 [stack 0]
 Group {
  name InverseEOTF
  xpos -40
  ypos 158
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG "" "" ""}}
  eotf PQ
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -160
  }
  Dot {
   name Dot1
   xpos 434
   ypos -96
  }
set N305c1400 [stack 0]
  Dot {
   name Dot3
   xpos 544
   ypos -96
  }
set N305c1000 [stack 0]
  Dot {
   name Dot4
   xpos 654
   ypos -96
  }
  Expression {
   temp_name0 Yd
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 r*pow(Yd,(1-_g)/_g)
   expr1 g*pow(Yd,(1-_g)/_g)
   expr2 b*pow(Yd,(1-_g)/_g)
   name HLG_InverseOOTF
   xpos 620
   ypos -70
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lw/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lw R 600 4000}
   Lw {{parent.parent.Lw}}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
  Expression {
   expr0 r<=1/12?sqrt(3*r):_a*log(12*r-_b)+_c
   expr1 g<=1/12?sqrt(3*g):_a*log(12*g-_b)+_c
   expr2 b<=1/12?sqrt(3*b):_a*log(12*b-_b)+_c
   name HLG_OETF
   xpos 620
   ypos -38
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
push $N305c1000
  Expression {
   expr0 pow((c_1+c_2*pow(r*Lw/10000,m_1))/(1+c_3*pow(r*Lw/10000,m_1)),m_2)
   expr1 pow((c_1+c_2*pow(g*Lw/10000,m_1))/(1+c_3*pow(g*Lw/10000,m_1)),m_2)
   expr2 pow((c_1+c_2*pow(b*Lw/10000,m_1))/(1+c_3*pow(b*Lw/10000,m_1)),m_2)
   name ST2084_InverseEOTF
   xpos 510
   ypos -70
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
   addUserKnob {7 Lw t "Display peak luminance in nits" R 600 4000}
   Lw 10000
  }
push $N305c1400
  Expression {
   expr0 sign(r)*pow(fabs(r),1/p)
   expr1 sign(g)*pow(fabs(g),1/p)
   expr2 sign(b)*pow(fabs(b),1/p)
   name power
   selected true
   xpos 400
   ypos -70
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos -10
  }
  Output {
   name Output
   xpos 400
   ypos 50
  }
 end_group
 Switch {
  inputs 2
  which {{parent.direction}}
  name SwitchDirection
  xpos -40
  ypos 230
 }
 Output {
  name Output
  xpos -40
  ypos 302
 }
 StickyNote {
  inputs 0
  name StickyNote1
  tile_color 0x272727ff
  label "<left><pre>\n<b>\"rgbDT\" render gamut</b>\nrxy 0.859 0.264\ngxy 0.137 1.12\nbxy 0.085 -0.096\nwxy 0.3127 0.329"
  note_font "Nimbus Sans \[UKWN]"
  note_font_color 0xa8a8a8ff
  xpos -244
  ypos -171
 }
push $N30636000
 Expression {
  temp_name0 rs
  temp_expr0 sy*pow(r/(r+sx),p)
  temp_name1 gs
  temp_expr1 sy*pow(g/(g+sx),p)
  temp_name2 bs
  temp_expr2 sy*pow(b/(b+sx),p)
  expr0 rs*rs/(rs+fl)
  expr1 gs*gs/(gs+fl)
  expr2 bs*bs/(bs+fl)
  name ToneScale
  xpos -11
  ypos -56
  addUserKnob {20 Params}
  addUserKnob {7 Lw R 100 4000}
  Lw 1000
  addUserKnob {7 c l contrast R 0.8 2}
  c {{12*pow(Lw,-0.86)+1.17}}
  addUserKnob {4 su l surround t "dark = 1.0\ndim = 0.95\naverage = 0.90" M {average dim dark}}
  su dim
  addUserKnob {7 p R 1 2}
  p {{c*(0.9+0.05*su)}}
  addUserKnob {7 fl l flare R 0 0.01}
  fl {{1/Lw}}
  addUserKnob {7 sx R 0 10}
  sx {{0.016*pow(Lw,0.87)-0.17}}
  addUserKnob {7 sy R 0 4}
  sy {{1.036+5e-5*Lw}}
 }
push $N30635800
push $N305c1c00
 Viewer {
  inputs 2
  frame_range 1-112
  gl_buffer_depth half-float
  name Viewer1
  xpos -167
  ypos 2
 }
end_group
Group {
 name Write_ResolveACES_ODT_LUT9
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 207
 ypos 460
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate A
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec2100
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateA rev008 Rec2100.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N1aee8c00
Dot {
 name Dot3
 xpos 445
 ypos 265
}
set N1aee8800 [stack 0]
Group {
 name OpenDRT
 label "v.0.1.2\nLp = \[value Lp]\n\[value eotf] - \[value display_gamut]"
 xpos 411
 ypos 341
 addUserKnob {20 OpenDRT}
 addUserKnob {26 about_label l " " T "<style> a:link \{ color: #ccc \}</style>\n<font color=#ccc>\n<b>OpenDRT</b> created by Jed Smith\n<br>v0.1.2 | <a href=https://github.com/jedypod/open-display-transform>documentation</a><br>"}
 addUserKnob {41 gamut l "in gamut" T InGamut_to_XYZ.gamut}
 addUserKnob {26 spacer l " " T ""}
 addUserKnob {35 presets l " " M {"presets/Rec.1886: 2.4 Power | Rec.709" "knobs this \{Lp 100 su 1 wp 3 eotf 2 display_gamut 4\}" "presets/sRGB Display: 2.2 Power | Rec.709" "knobs this \{Lp 100 su 0 wp 3 eotf 1 display_gamut 4\}" "presets/Apple Display P3: 2.2 Power | P3D65" "knobs this \{Lp 100 su 0 wp 3 eotf 1 display_gamut 1\}" "presets/Rec.2020: 2.4 Power | Rec.2020" "knobs this \{Lp 100 su 1 wp 3 eotf 2 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 100 nit" "knobs this \{Lp 100 su 1 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 600 nit" "knobs this \{Lp 600 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 1000 nit" "knobs this \{Lp 1000 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: HLG | Rec.2020 | 1000 nit" "knobs this \{Lp 1000 su 2 wp 3 eotf 5 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 2000 nit" "knobs this \{Lp 2000 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 4000 nit" "knobs this \{Lp 4000 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Dolby: ST 2084 PQ | P3D65 | 100 nit" "knobs this \{Lp 100 su 1 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 600 nit" "knobs this \{Lp 600 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 1000 nit" "knobs this \{Lp 1000 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 2000 nit" "knobs this \{Lp 2000 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 4000 nit" "knobs this \{Lp 4000 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/DCI: 2.6 Power | P3 D60" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 2\}" "presets/DCI: 2.6 Power | P3 D65" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 1\}" "presets/DCI: 2.6 Power | P3 DCI" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 3\}" "presets/DCI: 2.6 Power | DCDM XYZ" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 5\}"}}
 addUserKnob {26 ""}
 addUserKnob {26 luminance_label l " " T <b>luminance</b>}
 addUserKnob {41 Lp T ToneScale.Lp}
 addUserKnob {41 su l surround T ToneScale.su}
 addUserKnob {26 chroma_label l " " T "<br/>\n<b>chroma</b>"}
 addUserKnob {41 dch l dechroma T ToneScale.dch}
 addUserKnob {41 wp l whitepoint T Scale.wp}
 addUserKnob {26 ""}
 addUserKnob {26 display_encoding_label l " " T "<b>display encoding</b>"}
 addUserKnob {41 eotf T InverseEOTF.eotf}
 addUserKnob {41 display_gamut l gamut -STARTLINE T XYZ_to_DisplayGamut.gamut}
 addUserKnob {6 clamp t "clamp output to a 0-1 range" -STARTLINE}
 clamp true
 addUserKnob {26 ""}
 addUserKnob {4 direction M {forward inverse}}
}
 Input {
  inputs 0
  name Input
  xpos 180
  ypos -634
 }
set N45d3d400 [stack 0]
 Group {
  name EOTF
  xpos 510
  ypos -562
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf l EOTF t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG ""}}
  eotf {{parent.InverseEOTF.eotf}}
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -130
  }
set N45d3d000 [stack 0]
  Expression {
   expr0 r<=0.5?r*r/3:(exp((r-_c)/_a)+_b)/12
   expr1 g<=0.5?g*g/3:(exp((g-_c)/_a)+_b)/12
   expr2 b<=0.5?b*b/3:(exp((b-_c)/_a)+_b)/12
   name HLG_InverseOETF
   xpos 620
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
  Expression {
   temp_name0 Ys
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 pow(Ys,_g-1)*r
   expr1 pow(Ys,_g-1)*g
   expr2 pow(Ys,_g-1)*b
   name HLG_OOTF
   xpos 620
   ypos -32
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lp/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lp R 600 4000}
   Lp {{parent.parent.Lp}}
   addUserKnob {7 Lb}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
push $N45d3d000
  Expression {
   temp_name0 rp
   temp_expr0 pow(r,1/m_2)
   temp_name1 gp
   temp_expr1 pow(g,1/m_2)
   temp_name2 bp
   temp_expr2 pow(b,1/m_2)
   expr0 pow((rp-c_1)/(c_2-c_3*rp),1/m_1)
   expr1 pow((gp-c_1)/(c_2-c_3*gp),1/m_1)
   expr2 pow((bp-c_1)/(c_2-c_3*bp),1/m_1)
   name ST2084_EOTF
   xpos 510
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
  }
push $N45d3d000
  Expression {
   expr0 sign(r)*pow(fabs(r),p)
   expr1 sign(g)*pow(fabs(g),p)
   expr2 sign(b)*pow(fabs(b),p)
   name Power
   xpos 400
   ypos -58
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos -10
  }
  Output {
   name Output
   xpos 400
   ypos 62
  }
 end_group
 Expression {
  temp_name0 mx
  temp_expr0 dcdm?1:_s*Lp/100
  expr0 parent.clamp?max(0,min(mx,r)/_s):r/_s
  expr1 parent.clamp?max(0,min(mx,g)/_s):g/_s
  expr2 parent.clamp?max(0,min(mx,b)/_s):b/_s
  name InvDisplayScale
  xpos 510
  ypos -514
  addUserKnob {20 Params}
  addUserKnob {6 pq +STARTLINE}
  pq {{eotf==4}}
  addUserKnob {6 hlg -STARTLINE}
  hlg {{eotf==5}}
  addUserKnob {6 dcdm -STARTLINE}
  dcdm {{eotf==3&&display_gamut==5}}
  addUserKnob {7 _s}
  _s {{pq?0.01:hlg?0.1:dcdm?48/52.37:100/Lp}}
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
    }
  invert true
  name Inv_XYZ_to_DisplayGamut
  xpos 510
  ypos -466
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
    }
  name Inv_LMS_to_XYZ6
  xpos 510
  ypos -442
 }
 Expression {
  expr0 n*r/w.0
  expr1 n*g/w.1
  expr2 n*b/w.2
  name InvScale
  xpos 510
  ypos -394
  addUserKnob {20 Params}
  addUserKnob {78 w n 3}
  w {{parent.Scale.w} {parent.Scale.w} {parent.Scale.w}}
  addUserKnob {7 n R 0 4}
  n {{parent.Scale.wn}}
 }
 Dot {
  name Dot2
  xpos 544
  ypos -342
 }
set N45cc2400 [stack 0]
 Expression {
  channel0 rgba
  expr0 sqrt((w.0*r)**2+(w.1*g)**2+(w.2*b)**2)/sum
  name Norm1
  xpos 400
  ypos -297
  addUserKnob {20 Params}
  addUserKnob {78 w l weights n 3}
  w {{parent.Norm.w} {parent.Norm.w} {parent.Norm.w}}
  addUserKnob {7 sum t "Normalize so achromatic in=out" R 0 2}
  sum {{parent.Norm.sum}}
 }
set N45cc2000 [stack 0]
 Expression {
  temp_name0 tf
  temp_expr0 (r+sqrt(r*(4*fl+r)))/2
  temp_name1 ts
  temp_expr1 s0/((s1/tf)**(1/p)-1)
  temp_name2 tc
  temp_expr2 ts<0.18?(ts/cs)**(1/c0):(ts-0.18)/c0+0.18
  temp_name3 ccf
  temp_expr3 pow(s0/(tc+s0),dch)*sat
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 tc
  expr3 ccf
  name InvToneScale
  xpos 398
  ypos -264
  addUserKnob {20 Params}
  addUserKnob {7 c0 R 0 4}
  c0 {{parent.ToneScale.c0}}
  addUserKnob {7 cs R 0 4}
  cs {{0.18**(1-c0)}}
  addUserKnob {7 p R 1 1.4}
  p {{parent.ToneScale.p}}
  addUserKnob {7 fl R 0 0.02}
  fl {{parent.ToneScale.fl}}
  addUserKnob {7 s1 R 1 40}
  s1 {{parent.ToneScale.s1}}
  addUserKnob {7 s0 R 0 4}
  s0 {{parent.ToneScale.s0}}
  addUserKnob {26 ""}
  addUserKnob {7 dch}
  dch {{parent.ToneScale.dch}}
  addUserKnob {7 sat R 1 1.2}
  sat {{parent.ToneScale.sat}}
 }
set N45cc1c00 [stack 0]
push $N45cc1c00
push $N45cc2000
push $N45cc2400
 MergeExpression {
  inputs 2
  expr0 Ar==0?0:Br/Ar
  expr1 Ag==0?0:Bg/Ag
  expr2 Ab==0?0:Bb/Ab
  name MergeDivideReverse1
  xpos 510
  ypos -298
 }
 MergeExpression {
  inputs 2
  temp_name0 f
  temp_expr0 Aa
  expr0 ((f-1)+r)/f
  expr1 ((f-1)+g)/f
  expr2 ((f-1)+b)/f
  name InvChromaCompression
  xpos 510
  ypos -273
 }
 Merge2 {
  inputs 2
  operation multiply
  bbox B
  output rgb
  name Merge1
  xpos 510
  ypos -249
 }
 Expression {
  expr0 r*w.0
  expr1 g*w.1
  expr2 b*w.2
  name InvNormalize
  xpos 510
  ypos -178
  addUserKnob {20 Params}
  addUserKnob {78 w n 3}
  w {{parent.Normalize.w} {parent.Normalize.w} {parent.Normalize.w}}
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
    }
  invert true
  name Inv_XYZ_to_LMS
  xpos 510
  ypos -130
 }
 ColorMatrix {
  matrix {
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
    }
  invert true
  name Inv_InGamut_to_XYZ1
  xpos 510
  ypos -82
 }
push $N45d3d400
 Group {
  name InGamut_to_XYZ
  tile_color 0x429940ff
  xpos 180
  ypos -514
  addUserKnob {20 InputGamut_to_XYZ_tab l InputGamut_to_XYZ}
  addUserKnob {4 gamut l "in gamut" M {ACES ACEScg P3D65 Rec.2020 Rec.709 "Alexa WideGamut" "Red WideGamutRGB" "Sony SGamut3" "Filmlight E-Gamut" "DaVinci Wide Gamut" "" "" ""}}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -610
  }
  Dot {
   name Dot1
   xpos 324
   ypos -546
  }
set N45c33800 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -370
  }
  Output {
   name Output
   xpos 290
   ypos -250
  }
push $N45c33800
  Dot {
   name Dot391
   label " *RGB to XYZ D65 CAT: XYZ Scaling"
   xpos 434
   ypos -546
  }
set N45c32c00 [stack 0]
  ColorMatrix {
   matrix {
       {0.7006223202 0.1487748027 0.101058729}
       {0.2741184831 0.8736317754 -0.1477504224}
       {-0.09896290302 -0.1378953159 1.325916052}
     }
   name ColorMatrix30
   label "DaVinci WG to XYZ D65"
   xpos 1390
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.705396831 0.1640413404 0.08101775497}
       {0.2801307142 0.8202067018 -0.1003373787}
       {-0.1037815139 -0.07290726155 1.265746593}
     }
   name ColorMatrix29
   label "Filmlight E-Gamut to XYZ D65"
   xpos 1280
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.5990839005 0.2489254922 0.1024464965}
       {0.2150758207 0.8850684166 -0.1001443192}
       {-0.03206584975 -0.02765838802 1.148782015}
     }
   name ColorMatrix31
   label "SonySGamut3 to XYZ D65"
   xpos 1170
   ypos -465
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.735275209 0.06860940903 0.1465712786}
       {0.2866940796 0.8429790735 -0.1296732426}
       {-0.07968084514 -0.3473432064 1.516081929}
     }
   name ColorMatrix22
   label "REDWideGamutRGB to XYZ D65"
   xpos 1060
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.6380076408 0.2147038132 0.09774445742}
       {0.2919537723 0.8238408566 -0.1157948226}
       {0.002798279049 -0.06703422219 1.153293848}
     }
   name ColorMatrix21
   label "Arri AlexaWideGamut to XYZ D65"
   xpos 950
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.4123909175 0.3575843573 0.1804807931}
       {0.2126390785 0.7151687145 0.07219231129}
       {0.01933082566 0.1191947833 0.9505321383}
     }
   name ColorMatrix18
   label "Rec709 to XYZ D65"
   xpos 840
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.6369581223 0.1446169168 0.1688809693}
       {0.2627002299 0.6779981256 0.05930171534}
       {4.99410725e-17 0.02807269618 1.060985088}
     }
   name ColorMatrix17
   label "Rec2020 to XYZ D65"
   xpos 730
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.4865711331 0.2656677067 0.1982173175}
       {0.2289746404 0.6917386055 0.07928691804}
       {-3.972076965e-17 0.04511338845 1.043944478}
     }
   name ColorMatrix16
   label "P3D65 to XYZ D65"
   xpos 620
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.6609312296 0.1336961389 0.1558285803}
       {0.2722287476 0.6740817428 0.05368950963}
       {-0.006018006243 0.004383686464 1.090692043}
     }
   name ColorMatrix1
   label "ACEScg to XYZ D65"
   xpos 510
   ypos -466
  }
push $N45c32c00
  ColorMatrix {
   matrix {
       {0.9503623843 0 9.346324805e-05}
       {0.3439664543 0.728166163 -0.07213254273}
       {0 0 1.089057803}
     }
   name ColorMatrix2
   label "ACES to XYZ D65"
   xpos 400
   ypos -466
  }
  Switch {
   inputs 10
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -370
  }
 end_group
 ColorMatrix {
  matrix {
      {0.257085 0.859943 -0.031061}
      {-0.394427 1.1758 0.106423}
      {0.064856 -0.07625 0.559067}
    }
  name XYZ_to_LMS
  xpos 180
  ypos -490
 }
 Expression {
  expr0 r/w.0
  expr1 g/w.1
  expr2 b/w.2
  name Normalize
  xpos 180
  ypos -464
  addUserKnob {20 Params}
  addUserKnob {35 presets l "" +STARTLINE M {presets/D50 "knobs this \{w \{1.08221 0.883260 0.447579\}\}" presets/D55 "knobs this \{w \{1.07730 0.896467 0.500927\}\}" presets/D60 "knobs this \{w \{1.07344 0.907523 0.549381\}\}" presets/D65 "knobs this \{w \{1.07046 0.916817 0.594251\}\}" presets/D75 "knobs this \{w \{1.06600 0.931715 0.670839\}\}" presets/D93 "knobs this \{w \{1.06098 0.950462 0.776150\}\}"}}
  addUserKnob {78 w n 3}
  w {1.07046 0.916817 0.594251}
 }
 Dot {
  name Dot1
  xpos 214
  ypos -414
 }
set N45bd3400 [stack 0]
 Expression {
  channel0 rgba
  expr0 sqrt(max(1e-12,w.0*r)**2+max(1e-12,w.1*g)**2+max(1e-12,w.2*b)**2)/sum
  name Norm
  xpos 70
  ypos -395
  addUserKnob {20 Params}
  addUserKnob {78 w l weights n 3}
  w {0.18 0.1 0.1}
  addUserKnob {7 sum t "Normalize so achromatic in=out" R 0 2}
  sum {{sqrt(w.0*w.0+w.1*w.1+w.2*w.2)}}
 }
set N45bd3000 [stack 0]
 Expression {
  temp_name0 tc
  temp_expr0 r<0.18?cs*r**c0:c0*(r-0.18)+0.18
  temp_name1 ts
  temp_expr1 s1*(tc/(s0+tc))**p
  temp_name2 tf
  temp_expr2 ts*ts/(ts+fl)
  temp_name3 ccf
  temp_expr3 pow(s0/(r+s0),dch)*sat
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 tf
  expr3 ccf
  name ToneScale
  xpos 70
  ypos -369
  addUserKnob {20 Params}
  addUserKnob {7 Lp R 100 4000}
  Lp 100
  addUserKnob {4 su l surround t "dark = 1.0\ndim = 0.95\naverage = 0.90" M {average dim dark}}
  su dark
  addUserKnob {7 c0 t "pre-tonemap contrast" R 1 1.4}
  c0 1.2
  addUserKnob {7 cs t "pivoted contrast scale" R 0 4}
  cs {{0.18**(1-c0)}}
  addUserKnob {7 c1 t "post-tonemap contrast" R 1 1.2}
  c1 1.1
  addUserKnob {7 p R 1 1.4}
  p {{c1*(0.9+0.05*su)}}
  addUserKnob {26 ""}
  addUserKnob {7 w1 R 1 1.3}
  w1 {{(0.595*Lp/10000)**0.931+1.037}}
  addUserKnob {7 s1 R 1 40}
  s1 {{w1*Lp/100}}
  addUserKnob {26 ""}
  addUserKnob {7 ex t exposure R -2 2}
  ex -0.26
  addUserKnob {7 eb R 0 0.2}
  eb 0.08
  addUserKnob {7 e0 R 0 4}
  e0 {{2**(ex+eb*log(s1)/log(2))}}
  addUserKnob {7 s0 R 0 4}
  s0 {{(s1/e0)**(1/c1)}}
  addUserKnob {7 fl l flare R 0 0.02}
  fl 0.01
  addUserKnob {26 ""}
  addUserKnob {7 dch l dechroma}
  dch 0.55
  addUserKnob {7 sat l saturation R 1 1.2}
  sat {{max(1,1.125-0.00025*Lp)}}
 }
set N45bd2c00 [stack 0]
push $N45bd2c00
push $N45bd3000
push $N45bd3400
 MergeExpression {
  inputs 2
  expr0 Ar==0?0:Br/Ar
  expr1 Ag==0?0:Bg/Ag
  expr2 Ab==0?0:Bb/Ab
  name MergeDivideReverse
  xpos 180
  ypos -394
 }
 MergeExpression {
  inputs 2
  temp_name0 f
  temp_expr0 Aa
  expr0 (1-f)+r*f
  expr1 (1-f)+g*f
  expr2 (1-f)+b*f
  name ChromaCompression
  xpos 180
  ypos -367
 }
 Merge2 {
  inputs 2
  operation multiply
  bbox B
  output rgb
  name Merge2
  xpos 180
  ypos -343
 }
 Expression {
  expr0 r*w.0/wn
  expr1 g*w.1/wn
  expr2 b*w.2/wn
  expr3 1
  name Scale
  xpos 180
  ypos -302
  addUserKnob {20 Params}
  addUserKnob {4 wp M {D50 D55 D60 D65 D75 D93}}
  wp D65
  addUserKnob {78 w n 3}
  w {{curve(wp) 1.08221 1.0773 1.07344 1.07046 1.066 1.06098} {curve(wp) 0.88326 0.896467 0.907523 0.916817 0.931715 0.950462} {curve(wp) 0.447579 0.500927 0.549381 0.594251 0.670839 0.77615}}
  addUserKnob {7 wn R 0 2}
  wn {{curve(wp+6*display_gamut) 1.09063 1.05337 1.02355 1 1.12915 1.30631 1.1408 1.08334 1.037 1 1.13116 1.31116 1.09928 1.04391 1.00028 1.08307 1.22512 1.42007 1.2469 1.18409 1.13345 1.15054 1.30144 1.50853 1.17646 1.10416 1.0461 1 1.14486 1.34374 1 1 1 1 1 1}}
 }
set N45bd1c00 [stack 0]
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
    }
  invert true
  name LMS_to_XYZ
  xpos 180
  ypos -253
 }
 Group {
  name XYZ_to_DisplayGamut
  tile_color 0x425440ff
  xpos 180
  ypos -203
  addUserKnob {20 XYZ_to_DisplayGamut_tab l XYZ_to_DisplayGamut}
  addUserKnob {4 gamut l "display gamut" t "Choose the target display device chromaticities." M {Rec.2020 "P3 D65" "P3 D60" "P3 DCI" Rec.709 "DCDM X'Y'Z'"}}
  gamut Rec.709
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -580
  }
  Dot {
   name Dot391
   label " "
   xpos 324
   ypos -516
  }
set N45bd1000 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -399
  }
  Output {
   name Output
   xpos 290
   ypos -310
  }
push $N45bd1000
  Dot {
   name Dot1
   label " XYZ D65 to *RGB CAT: XYZ Scaling"
   xpos 434
   ypos -516
  }
set N45bd0400 [stack 0]
  ColorMatrix {
   matrix {
       {1 0 0}
       {0 1 0}
       {0 0 1}
     }
   name ColorMatrix4
   label "XYZ D65 to XYZ E"
   xpos 950
   ypos -465
  }
push $N45bd0400
  ColorMatrix {
   matrix {
       {3.240968943 -1.537382722 -0.4986106157}
       {-0.9692435861 1.875967264 0.04155508429}
       {0.05563007668 -0.2039769441 1.056971431}
     }
   name ColorMatrix2
   label "XYZ D65 to Rec709"
   xpos 840
   ypos -465
  }
push $N45bd0400
  ColorMatrix {
   matrix {
       {2.72539258 -1.01800251 -0.4401629865}
       {-0.795167923 1.689731836 0.02264717408}
       {0.04124189168 -0.08763902634 1.100929379}
     }
   name ColorMatrix12
   label "XYZ D65 to P3DCI"
   xpos 730
   ypos -465
  }
push $N45bd0400
  ColorMatrix {
   matrix {
       {2.40274024 -0.8974836469 -0.3880532086}
       {-0.8325793743 1.769231319 0.02371269651}
       {0.03882337734 -0.0824996829 1.036368608}
     }
   name ColorMatrix11
   label "XYZ D65 to P3D60"
   xpos 620
   ypos -465
  }
push $N45bd0400
  ColorMatrix {
   matrix {
       {2.493495464 -0.9313831329 -0.4027105868}
       {-0.8294886947 1.762663484 0.02362468652}
       {0.03584581986 -0.07617236674 0.9568843246}
     }
   name ColorMatrix10
   label "XYZ D65 to P3D65"
   xpos 510
   ypos -465
  }
push $N45bd0400
  ColorMatrix {
   matrix {
       {1.716650844 -0.3556707203 -0.2533662021}
       {-0.6666842103 1.616480947 0.01576854289}
       {0.01763985492 -0.04277061298 0.9421030283}
     }
   name ColorMatrix5
   label "XYZ D65 to Rec2020"
   xpos 400
   ypos -465
  }
  Switch {
   inputs 6
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -399
  }
 end_group
 Expression {
  temp_name0 mx
  temp_expr0 dcdm?1:_s*Lp/100
  channel0 {rgba.red -rgba.green -rgba.blue none}
  expr0 parent.clamp?max(0,min(mx,r*_s)):r*_s
  expr1 parent.clamp?max(0,min(mx,g*_s)):g*_s
  expr2 parent.clamp?max(0,min(mx,b*_s)):b*_s
  name DisplayScale
  xpos 180
  ypos -153
  addUserKnob {20 Params}
  addUserKnob {6 pq +STARTLINE}
  pq {{eotf==4}}
  addUserKnob {6 hlg -STARTLINE}
  hlg {{eotf==5}}
  addUserKnob {6 dcdm -STARTLINE}
  dcdm {{eotf==3&&display_gamut==5}}
  addUserKnob {7 _s}
  _s {{pq?0.01:hlg?0.1:dcdm?48/52.37:100/Lp}}
 }
 Group {
  name InverseEOTF
  xpos 180
  ypos -104
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG "" "" ""}}
  eotf BT.1886
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -129
  }
set N45f62000 [stack 0]
  Expression {
   temp_name0 Yd
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 r==0?0:r*pow(Yd,(1-_g)/_g)
   expr1 g==0?0:g*pow(Yd,(1-_g)/_g)
   expr2 b==0?0:b*pow(Yd,(1-_g)/_g)
   name HLG_InverseOOTF
   xpos 620
   ypos -57
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lp/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lw R 600 4000}
   Lw {{parent.parent.Lp}}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
  Expression {
   expr0 r<=1/12?sqrt(3*r):_a*log(12*r-_b)+_c
   expr1 g<=1/12?sqrt(3*g):_a*log(12*g-_b)+_c
   expr2 b<=1/12?sqrt(3*b):_a*log(12*b-_b)+_c
   name HLG_OETF
   xpos 620
   ypos -34
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
push $N45f62000
  Expression {
   temp_name0 rp
   temp_expr0 pow(r,m_1)
   temp_name1 gp
   temp_expr1 pow(g,m_1)
   temp_name2 bp
   temp_expr2 pow(b,m_1)
   expr0 pow((c_1+c_2*rp)/(1+c_3*rp),m_2)
   expr1 pow((c_1+c_2*gp)/(1+c_3*gp),m_2)
   expr2 pow((c_1+c_2*bp)/(1+c_3*bp),m_2)
   name ST2084_InverseEOTF
   xpos 510
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
  }
push $N45f62000
  Expression {
   expr0 sign(r)*pow(fabs(r),1/p)
   expr1 sign(g)*pow(fabs(g),1/p)
   expr2 sign(b)*pow(fabs(b),1/p)
   name power
   xpos 400
   ypos -58
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos 14
  }
  Output {
   name Output
   xpos 400
   ypos 86
  }
 end_group
 Switch {
  inputs 2
  which {{parent.direction}}
  name SwitchDirection
  xpos 180
  ypos -34
 }
 Output {
  name Output
  xpos 180
  ypos 38
 }
push $N45bd1c00
 Viewer {
  frame_range 1-100
  gl_buffer_depth half-float
  name Viewer1
  selected true
  xpos 180
  ypos -440
 }
end_group
set N45d48100 [stack 0]
Group {
 name Write_ResolveACES_ODT_LUT2
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 411
 ypos 465
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate B
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec709
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateB rev008 Rec709.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N45d48100
Group {
 name SDR_to_HDR1
 xpos 522
 ypos 442
}
 Input {
  inputs 0
  name Input1
  xpos 692
  ypos -182
 }
 Colorspace {
  colorspace_in 2.40
  primary_out Rec.2020
  name Colorspace1
  xpos 692
  ypos -142
 }
 Multiply {
  value 100
  name Multiply1
  xpos 692
  ypos -118
 }
 Colorspace {
  colorspace_out st2084
  name Colorspace2
  selected true
  xpos 692
  ypos -86
 }
 Output {
  name Output1
  xpos 692
  ypos 14
 }
end_group
Group {
 name Write_ResolveACES_ODT_LUT11
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 522
 ypos 466
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate B
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (Rec709 sim)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateB rev008 Rec2100 (Rec709 sim).cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N1aee8800
Group {
 name OpenDRT1
 label "v.0.1.2\nLp = \[value Lp]\n\[value eotf] - \[value display_gamut]"
 xpos 627
 ypos 342
 addUserKnob {20 OpenDRT}
 addUserKnob {26 about_label l " " T "<style> a:link \{ color: #ccc \}</style>\n<font color=#ccc>\n<b>OpenDRT</b> created by Jed Smith\n<br>v0.1.2 | <a href=https://github.com/jedypod/open-display-transform>documentation</a><br>"}
 addUserKnob {41 gamut l "in gamut" T InGamut_to_XYZ.gamut}
 addUserKnob {26 spacer l " " T ""}
 addUserKnob {35 presets l " " M {"presets/Rec.1886: 2.4 Power | Rec.709" "knobs this \{Lp 100 su 1 wp 3 eotf 2 display_gamut 4\}" "presets/sRGB Display: 2.2 Power | Rec.709" "knobs this \{Lp 100 su 0 wp 3 eotf 1 display_gamut 4\}" "presets/Apple Display P3: 2.2 Power | P3D65" "knobs this \{Lp 100 su 0 wp 3 eotf 1 display_gamut 1\}" "presets/Rec.2020: 2.4 Power | Rec.2020" "knobs this \{Lp 100 su 1 wp 3 eotf 2 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 100 nit" "knobs this \{Lp 100 su 1 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 600 nit" "knobs this \{Lp 600 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 1000 nit" "knobs this \{Lp 1000 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: HLG | Rec.2020 | 1000 nit" "knobs this \{Lp 1000 su 2 wp 3 eotf 5 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 2000 nit" "knobs this \{Lp 2000 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Rec.2100: ST 2084 PQ | Rec.2020 | 4000 nit" "knobs this \{Lp 4000 su 2 wp 3 eotf 4 display_gamut 0\}" "presets/Dolby: ST 2084 PQ | P3D65 | 100 nit" "knobs this \{Lp 100 su 1 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 600 nit" "knobs this \{Lp 600 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 1000 nit" "knobs this \{Lp 1000 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 2000 nit" "knobs this \{Lp 2000 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/Dolby: ST 2084 PQ | P3D65 | 4000 nit" "knobs this \{Lp 4000 su 2 wp 3 eotf 4 display_gamut 1\}" "presets/DCI: 2.6 Power | P3 D60" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 2\}" "presets/DCI: 2.6 Power | P3 D65" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 1\}" "presets/DCI: 2.6 Power | P3 DCI" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 3\}" "presets/DCI: 2.6 Power | DCDM XYZ" "knobs this \{Lp 100 su 2 wp 3 eotf 3 display_gamut 5\}"}}
 addUserKnob {26 ""}
 addUserKnob {26 luminance_label l " " T <b>luminance</b>}
 addUserKnob {41 Lp T ToneScale.Lp}
 addUserKnob {41 su l surround T ToneScale.su}
 addUserKnob {26 chroma_label l " " T "<br/>\n<b>chroma</b>"}
 addUserKnob {41 dch l dechroma T ToneScale.dch}
 addUserKnob {41 wp l whitepoint T Scale.wp}
 addUserKnob {26 ""}
 addUserKnob {26 display_encoding_label l " " T "<b>display encoding</b>"}
 addUserKnob {41 eotf T InverseEOTF.eotf}
 addUserKnob {41 display_gamut l gamut -STARTLINE T XYZ_to_DisplayGamut.gamut}
 addUserKnob {6 clamp t "clamp output to a 0-1 range" -STARTLINE}
 clamp true
 addUserKnob {26 ""}
 addUserKnob {4 direction M {forward inverse}}
}
 Input {
  inputs 0
  name Input
  xpos 180
  ypos -634
 }
set N1aee8400 [stack 0]
 Group {
  name EOTF
  xpos 510
  ypos -562
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf l EOTF t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG ""}}
  eotf {{parent.InverseEOTF.eotf}}
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -130
  }
set N1ae8bc00 [stack 0]
  Expression {
   expr0 r<=0.5?r*r/3:(exp((r-_c)/_a)+_b)/12
   expr1 g<=0.5?g*g/3:(exp((g-_c)/_a)+_b)/12
   expr2 b<=0.5?b*b/3:(exp((b-_c)/_a)+_b)/12
   name HLG_InverseOETF
   xpos 620
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
  Expression {
   temp_name0 Ys
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 pow(Ys,_g-1)*r
   expr1 pow(Ys,_g-1)*g
   expr2 pow(Ys,_g-1)*b
   name HLG_OOTF
   xpos 620
   ypos -32
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lp/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lp R 600 4000}
   Lp {{parent.parent.Lp}}
   addUserKnob {7 Lb}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
push $N1ae8bc00
  Expression {
   temp_name0 rp
   temp_expr0 pow(r,1/m_2)
   temp_name1 gp
   temp_expr1 pow(g,1/m_2)
   temp_name2 bp
   temp_expr2 pow(b,1/m_2)
   expr0 pow((rp-c_1)/(c_2-c_3*rp),1/m_1)
   expr1 pow((gp-c_1)/(c_2-c_3*gp),1/m_1)
   expr2 pow((bp-c_1)/(c_2-c_3*bp),1/m_1)
   name ST2084_EOTF
   xpos 510
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
  }
push $N1ae8bc00
  Expression {
   expr0 sign(r)*pow(fabs(r),p)
   expr1 sign(g)*pow(fabs(g),p)
   expr2 sign(b)*pow(fabs(b),p)
   name Power
   xpos 400
   ypos -58
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos -10
  }
  Output {
   name Output
   xpos 400
   ypos 62
  }
 end_group
 Expression {
  temp_name0 mx
  temp_expr0 dcdm?1:_s*Lp/100
  expr0 parent.clamp?max(0,min(mx,r)/_s):r/_s
  expr1 parent.clamp?max(0,min(mx,g)/_s):g/_s
  expr2 parent.clamp?max(0,min(mx,b)/_s):b/_s
  name InvDisplayScale
  xpos 510
  ypos -514
  addUserKnob {20 Params}
  addUserKnob {6 pq +STARTLINE}
  pq {{eotf==4}}
  addUserKnob {6 hlg -STARTLINE}
  hlg {{eotf==5}}
  addUserKnob {6 dcdm -STARTLINE}
  dcdm {{eotf==3&&display_gamut==5}}
  addUserKnob {7 _s}
  _s {{pq?0.01:hlg?0.1:dcdm?48/52.37:100/Lp}}
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
      {{parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix} {parent.XYZ_to_DisplayGamut.ColorMatrix.matrix}}
    }
  invert true
  name Inv_XYZ_to_DisplayGamut
  xpos 510
  ypos -466
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
    }
  name Inv_LMS_to_XYZ6
  xpos 510
  ypos -442
 }
 Expression {
  expr0 n*r/w.0
  expr1 n*g/w.1
  expr2 n*b/w.2
  name InvScale
  xpos 510
  ypos -394
  addUserKnob {20 Params}
  addUserKnob {78 w n 3}
  w {{parent.Scale.w} {parent.Scale.w} {parent.Scale.w}}
  addUserKnob {7 n R 0 4}
  n {{parent.Scale.wn}}
 }
 Dot {
  name Dot2
  xpos 544
  ypos -342
 }
set N1ae89400 [stack 0]
 Expression {
  channel0 rgba
  expr0 sqrt((w.0*r)**2+(w.1*g)**2+(w.2*b)**2)/sum
  name Norm1
  xpos 400
  ypos -297
  addUserKnob {20 Params}
  addUserKnob {78 w l weights n 3}
  w {{parent.Norm.w} {parent.Norm.w} {parent.Norm.w}}
  addUserKnob {7 sum t "Normalize so achromatic in=out" R 0 2}
  sum {{parent.Norm.sum}}
 }
set N1ae89000 [stack 0]
 Expression {
  temp_name0 tf
  temp_expr0 (r+sqrt(r*(4*fl+r)))/2
  temp_name1 ts
  temp_expr1 s0/((s1/tf)**(1/p)-1)
  temp_name2 tc
  temp_expr2 ts<0.18?(ts/cs)**(1/c0):(ts-0.18)/c0+0.18
  temp_name3 ccf
  temp_expr3 pow(s0/(tc+s0),dch)*sat
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 tc
  expr3 ccf
  name InvToneScale
  xpos 398
  ypos -264
  addUserKnob {20 Params}
  addUserKnob {7 c0 R 0 4}
  c0 {{parent.ToneScale.c0}}
  addUserKnob {7 cs R 0 4}
  cs {{0.18**(1-c0)}}
  addUserKnob {7 p R 1 1.4}
  p {{parent.ToneScale.p}}
  addUserKnob {7 fl R 0 0.02}
  fl {{parent.ToneScale.fl}}
  addUserKnob {7 s1 R 1 40}
  s1 {{parent.ToneScale.s1}}
  addUserKnob {7 s0 R 0 4}
  s0 {{parent.ToneScale.s0}}
  addUserKnob {26 ""}
  addUserKnob {7 dch}
  dch {{parent.ToneScale.dch}}
  addUserKnob {7 sat R 1 1.2}
  sat {{parent.ToneScale.sat}}
 }
set N1ae88c00 [stack 0]
push $N1ae88c00
push $N1ae89000
push $N1ae89400
 MergeExpression {
  inputs 2
  expr0 Ar==0?0:Br/Ar
  expr1 Ag==0?0:Bg/Ag
  expr2 Ab==0?0:Bb/Ab
  name MergeDivideReverse1
  xpos 510
  ypos -298
 }
 MergeExpression {
  inputs 2
  temp_name0 f
  temp_expr0 Aa
  expr0 ((f-1)+r)/f
  expr1 ((f-1)+g)/f
  expr2 ((f-1)+b)/f
  name InvChromaCompression
  xpos 510
  ypos -273
 }
 Merge2 {
  inputs 2
  operation multiply
  bbox B
  output rgb
  name Merge1
  xpos 510
  ypos -249
 }
 Expression {
  expr0 r*w.0
  expr1 g*w.1
  expr2 b*w.2
  name InvNormalize
  xpos 510
  ypos -178
  addUserKnob {20 Params}
  addUserKnob {78 w n 3}
  w {{parent.Normalize.w} {parent.Normalize.w} {parent.Normalize.w}}
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
    }
  invert true
  name Inv_XYZ_to_LMS
  xpos 510
  ypos -130
 }
 ColorMatrix {
  matrix {
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
      {{parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix} {parent.InGamut_to_XYZ.ColorMatrix.matrix}}
    }
  invert true
  name Inv_InGamut_to_XYZ1
  xpos 510
  ypos -82
 }
push $N1aee8400
 Group {
  name InGamut_to_XYZ
  tile_color 0x429940ff
  xpos 180
  ypos -514
  addUserKnob {20 InputGamut_to_XYZ_tab l InputGamut_to_XYZ}
  addUserKnob {4 gamut l "in gamut" M {ACES ACEScg P3D65 Rec.2020 Rec.709 "Alexa WideGamut" "Red WideGamutRGB" "Sony SGamut3" "Filmlight E-Gamut" "DaVinci Wide Gamut" "" "" ""}}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -610
  }
  Dot {
   name Dot1
   xpos 324
   ypos -546
  }
set N1ae1e800 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -370
  }
  Output {
   name Output
   xpos 290
   ypos -250
  }
push $N1ae1e800
  Dot {
   name Dot391
   label " *RGB to XYZ D65 CAT: XYZ Scaling"
   xpos 434
   ypos -546
  }
set N1ae1dc00 [stack 0]
  ColorMatrix {
   matrix {
       {0.7006223202 0.1487748027 0.101058729}
       {0.2741184831 0.8736317754 -0.1477504224}
       {-0.09896290302 -0.1378953159 1.325916052}
     }
   name ColorMatrix30
   label "DaVinci WG to XYZ D65"
   xpos 1390
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.705396831 0.1640413404 0.08101775497}
       {0.2801307142 0.8202067018 -0.1003373787}
       {-0.1037815139 -0.07290726155 1.265746593}
     }
   name ColorMatrix29
   label "Filmlight E-Gamut to XYZ D65"
   xpos 1280
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.5990839005 0.2489254922 0.1024464965}
       {0.2150758207 0.8850684166 -0.1001443192}
       {-0.03206584975 -0.02765838802 1.148782015}
     }
   name ColorMatrix31
   label "SonySGamut3 to XYZ D65"
   xpos 1170
   ypos -465
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.735275209 0.06860940903 0.1465712786}
       {0.2866940796 0.8429790735 -0.1296732426}
       {-0.07968084514 -0.3473432064 1.516081929}
     }
   name ColorMatrix22
   label "REDWideGamutRGB to XYZ D65"
   xpos 1060
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.6380076408 0.2147038132 0.09774445742}
       {0.2919537723 0.8238408566 -0.1157948226}
       {0.002798279049 -0.06703422219 1.153293848}
     }
   name ColorMatrix21
   label "Arri AlexaWideGamut to XYZ D65"
   xpos 950
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.4123909175 0.3575843573 0.1804807931}
       {0.2126390785 0.7151687145 0.07219231129}
       {0.01933082566 0.1191947833 0.9505321383}
     }
   name ColorMatrix18
   label "Rec709 to XYZ D65"
   xpos 840
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.6369581223 0.1446169168 0.1688809693}
       {0.2627002299 0.6779981256 0.05930171534}
       {4.99410725e-17 0.02807269618 1.060985088}
     }
   name ColorMatrix17
   label "Rec2020 to XYZ D65"
   xpos 730
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.4865711331 0.2656677067 0.1982173175}
       {0.2289746404 0.6917386055 0.07928691804}
       {-3.972076965e-17 0.04511338845 1.043944478}
     }
   name ColorMatrix16
   label "P3D65 to XYZ D65"
   xpos 620
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.6609312296 0.1336961389 0.1558285803}
       {0.2722287476 0.6740817428 0.05368950963}
       {-0.006018006243 0.004383686464 1.090692043}
     }
   name ColorMatrix1
   label "ACEScg to XYZ D65"
   xpos 510
   ypos -466
  }
push $N1ae1dc00
  ColorMatrix {
   matrix {
       {0.9503623843 0 9.346324805e-05}
       {0.3439664543 0.728166163 -0.07213254273}
       {0 0 1.089057803}
     }
   name ColorMatrix2
   label "ACES to XYZ D65"
   xpos 400
   ypos -466
  }
  Switch {
   inputs 10
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -370
  }
 end_group
 ColorMatrix {
  matrix {
      {0.257085 0.859943 -0.031061}
      {-0.394427 1.1758 0.106423}
      {0.064856 -0.07625 0.559067}
    }
  name XYZ_to_LMS
  xpos 180
  ypos -490
 }
 Expression {
  expr0 r/w.0
  expr1 g/w.1
  expr2 b/w.2
  name Normalize
  xpos 180
  ypos -464
  addUserKnob {20 Params}
  addUserKnob {35 presets l "" +STARTLINE M {presets/D50 "knobs this \{w \{1.08221 0.883260 0.447579\}\}" presets/D55 "knobs this \{w \{1.07730 0.896467 0.500927\}\}" presets/D60 "knobs this \{w \{1.07344 0.907523 0.549381\}\}" presets/D65 "knobs this \{w \{1.07046 0.916817 0.594251\}\}" presets/D75 "knobs this \{w \{1.06600 0.931715 0.670839\}\}" presets/D93 "knobs this \{w \{1.06098 0.950462 0.776150\}\}"}}
  addUserKnob {78 w n 3}
  w {1.07046 0.916817 0.594251}
 }
 Dot {
  name Dot1
  xpos 214
  ypos -414
 }
set N1adb6400 [stack 0]
 Expression {
  channel0 rgba
  expr0 sqrt(max(1e-12,w.0*r)**2+max(1e-12,w.1*g)**2+max(1e-12,w.2*b)**2)/sum
  name Norm
  xpos 70
  ypos -395
  addUserKnob {20 Params}
  addUserKnob {78 w l weights n 3}
  w {0.18 0.1 0.1}
  addUserKnob {7 sum t "Normalize so achromatic in=out" R 0 2}
  sum {{sqrt(w.0*w.0+w.1*w.1+w.2*w.2)}}
 }
set N1adb6000 [stack 0]
 Expression {
  temp_name0 tc
  temp_expr0 r<0.18?cs*r**c0:c0*(r-0.18)+0.18
  temp_name1 ts
  temp_expr1 s1*(tc/(s0+tc))**p
  temp_name2 tf
  temp_expr2 ts*ts/(ts+fl)
  temp_name3 ccf
  temp_expr3 pow(s0/(r+s0),dch)*sat
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 tf
  expr3 ccf
  name ToneScale
  xpos 70
  ypos -369
  addUserKnob {20 Params}
  addUserKnob {7 Lp R 100 4000}
  Lp 1000
  addUserKnob {4 su l surround t "dark = 1.0\ndim = 0.95\naverage = 0.90" M {average dim dark}}
  su dark
  addUserKnob {7 c0 t "pre-tonemap contrast" R 1 1.4}
  c0 1.2
  addUserKnob {7 cs t "pivoted contrast scale" R 0 4}
  cs {{0.18**(1-c0)}}
  addUserKnob {7 c1 t "post-tonemap contrast" R 1 1.2}
  c1 1.1
  addUserKnob {7 p R 1 1.4}
  p {{c1*(0.9+0.05*su)}}
  addUserKnob {26 ""}
  addUserKnob {7 w1 R 1 1.3}
  w1 {{(0.595*Lp/10000)**0.931+1.037}}
  addUserKnob {7 s1 R 1 40}
  s1 {{w1*Lp/100}}
  addUserKnob {26 ""}
  addUserKnob {7 ex t exposure R -2 2}
  ex -0.26
  addUserKnob {7 eb R 0 0.2}
  eb 0.08
  addUserKnob {7 e0 R 0 4}
  e0 {{2**(ex+eb*log(s1)/log(2))}}
  addUserKnob {7 s0 R 0 4}
  s0 {{(s1/e0)**(1/c1)}}
  addUserKnob {7 fl l flare R 0 0.02}
  fl 0.01
  addUserKnob {26 ""}
  addUserKnob {7 dch l dechroma}
  dch 0.55
  addUserKnob {7 sat l saturation R 1 1.2}
  sat {{max(1,1.125-0.00025*Lp)}}
 }
set N1adb5c00 [stack 0]
push $N1adb5c00
push $N1adb6000
push $N1adb6400
 MergeExpression {
  inputs 2
  expr0 Ar==0?0:Br/Ar
  expr1 Ag==0?0:Bg/Ag
  expr2 Ab==0?0:Bb/Ab
  name MergeDivideReverse
  xpos 180
  ypos -394
 }
 MergeExpression {
  inputs 2
  temp_name0 f
  temp_expr0 Aa
  expr0 (1-f)+r*f
  expr1 (1-f)+g*f
  expr2 (1-f)+b*f
  name ChromaCompression
  xpos 180
  ypos -369
 }
 Merge2 {
  inputs 2
  operation multiply
  bbox B
  output rgb
  name Merge2
  xpos 180
  ypos -343
 }
 Expression {
  expr0 r*w.0/wn
  expr1 g*w.1/wn
  expr2 b*w.2/wn
  expr3 1
  name Scale
  xpos 180
  ypos -302
  addUserKnob {20 Params}
  addUserKnob {4 wp M {D50 D55 D60 D65 D75 D93}}
  wp D65
  addUserKnob {78 w n 3}
  w {{curve(wp) 1.08221 1.0773 1.07344 1.07046 1.066 1.06098} {curve(wp) 0.88326 0.896467 0.907523 0.916817 0.931715 0.950462} {curve(wp) 0.447579 0.500927 0.549381 0.594251 0.670839 0.77615}}
  addUserKnob {7 wn R 0 2}
  wn {{curve(wp+6*display_gamut) 1.09063 1.05337 1.02355 1 1.12915 1.30631 1.1408 1.08334 1.037 1 1.13116 1.31116 1.09928 1.04391 1.00028 1.08307 1.22512 1.42007 1.2469 1.18409 1.13345 1.15054 1.30144 1.50853 1.17646 1.10416 1.0461 1 1.14486 1.34374 1 1 1 1 1 1}}
 }
 ColorMatrix {
  matrix {
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
      {{parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix} {parent.XYZ_to_LMS.matrix}}
    }
  invert true
  name LMS_to_XYZ
  selected true
  xpos 180
  ypos -253
 }
 Group {
  name XYZ_to_DisplayGamut
  tile_color 0x425440ff
  xpos 180
  ypos -203
  addUserKnob {20 XYZ_to_DisplayGamut_tab l XYZ_to_DisplayGamut}
  addUserKnob {4 gamut l "display gamut" t "Choose the target display device chromaticities." M {Rec.2020 "P3 D65" "P3 D60" "P3 DCI" Rec.709 "DCDM X'Y'Z'"}}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 }
  Input {
   inputs 0
   name Input
   xpos 290
   ypos -580
  }
  Dot {
   name Dot391
   label " "
   xpos 324
   ypos -516
  }
set N44fd3c00 [stack 0]
  ColorMatrix {
   matrix {
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
       {{"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"} {"SwitchGamut.input\[value SwitchGamut.which].matrix"}}
     }
   name ColorMatrix
   xpos 290
   ypos -399
  }
  Output {
   name Output
   xpos 290
   ypos -310
  }
push $N44fd3c00
  Dot {
   name Dot1
   label " XYZ D65 to *RGB CAT: XYZ Scaling"
   xpos 434
   ypos -516
  }
set N44fd3000 [stack 0]
  ColorMatrix {
   matrix {
       {1 0 0}
       {0 1 0}
       {0 0 1}
     }
   name ColorMatrix4
   label "XYZ D65 to XYZ E"
   xpos 950
   ypos -465
  }
push $N44fd3000
  ColorMatrix {
   matrix {
       {3.240968943 -1.537382722 -0.4986106157}
       {-0.9692435861 1.875967264 0.04155508429}
       {0.05563007668 -0.2039769441 1.056971431}
     }
   name ColorMatrix2
   label "XYZ D65 to Rec709"
   xpos 840
   ypos -465
  }
push $N44fd3000
  ColorMatrix {
   matrix {
       {2.72539258 -1.01800251 -0.4401629865}
       {-0.795167923 1.689731836 0.02264717408}
       {0.04124189168 -0.08763902634 1.100929379}
     }
   name ColorMatrix12
   label "XYZ D65 to P3DCI"
   xpos 730
   ypos -465
  }
push $N44fd3000
  ColorMatrix {
   matrix {
       {2.40274024 -0.8974836469 -0.3880532086}
       {-0.8325793743 1.769231319 0.02371269651}
       {0.03882337734 -0.0824996829 1.036368608}
     }
   name ColorMatrix11
   label "XYZ D65 to P3D60"
   xpos 620
   ypos -465
  }
push $N44fd3000
  ColorMatrix {
   matrix {
       {2.493495464 -0.9313831329 -0.4027105868}
       {-0.8294886947 1.762663484 0.02362468652}
       {0.03584581986 -0.07617236674 0.9568843246}
     }
   name ColorMatrix10
   label "XYZ D65 to P3D65"
   xpos 510
   ypos -465
  }
push $N44fd3000
  ColorMatrix {
   matrix {
       {1.716650844 -0.3556707203 -0.2533662021}
       {-0.6666842103 1.616480947 0.01576854289}
       {0.01763985492 -0.04277061298 0.9421030283}
     }
   name ColorMatrix5
   label "XYZ D65 to Rec2020"
   xpos 400
   ypos -465
  }
  Switch {
   inputs 6
   which {{gamut}}
   name SwitchGamut
   xpos 400
   ypos -399
  }
 end_group
 Expression {
  temp_name0 mx
  temp_expr0 dcdm?1:_s*Lp/100
  channel0 {rgba.red -rgba.green -rgba.blue none}
  expr0 parent.clamp?max(0,min(mx,r*_s)):r*_s
  expr1 parent.clamp?max(0,min(mx,g*_s)):g*_s
  expr2 parent.clamp?max(0,min(mx,b*_s)):b*_s
  name DisplayScale
  xpos 180
  ypos -153
  addUserKnob {20 Params}
  addUserKnob {6 pq +STARTLINE}
  pq {{eotf==4}}
  addUserKnob {6 hlg -STARTLINE}
  hlg {{eotf==5}}
  addUserKnob {6 dcdm -STARTLINE}
  dcdm {{eotf==3&&display_gamut==5}}
  addUserKnob {7 _s}
  _s {{pq?0.01:hlg?0.1:dcdm?48/52.37:100/Lp}}
 }
 Group {
  name InverseEOTF
  xpos 180
  ypos -104
  addUserKnob {20 EOTF_tab l EOTF}
  addUserKnob {4 eotf t "Choose the inverse EOTF to apply for the target display device." M {None "sRGB Display" BT.1886 "Gamma 2.6" PQ HLG "" "" ""}}
  eotf PQ
 }
  Input {
   inputs 0
   name Input
   xpos 400
   ypos -129
  }
set N44fd1000 [stack 0]
  Expression {
   temp_name0 Yd
   temp_expr0 0.2627*r+0.6780*g+0.0593*b
   expr0 r==0?0:r*pow(Yd,(1-_g)/_g)
   expr1 g==0?0:g*pow(Yd,(1-_g)/_g)
   expr2 b==0?0:b*pow(Yd,(1-_g)/_g)
   name HLG_InverseOOTF
   xpos 620
   ypos -57
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _g t "Gamma: Extended model for gamma variation according to peak display luminance and surround luminance: BT.2390-8 p32" R 0 2}
   _g {{1.2*pow(1.111,log(Lp/1000)/log(2))*pow(0.98,log(max(1e-6,Lamb)/5)/log(2))}}
   addUserKnob {7 Lw R 600 4000}
   Lw {{parent.parent.Lp}}
   addUserKnob {7 Lamb t "ambient luminance level in nits" R 0 200}
   Lamb 5
  }
  Expression {
   expr0 r<=1/12?sqrt(3*r):_a*log(12*r-_b)+_c
   expr1 g<=1/12?sqrt(3*g):_a*log(12*g-_b)+_c
   expr2 b<=1/12?sqrt(3*b):_a*log(12*b-_b)+_c
   name HLG_OETF
   xpos 620
   ypos -34
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 _a t alpha}
   _a 0.17883277
   addUserKnob {7 _b t beta}
   _b {{1-4*_a}}
   addUserKnob {7 _c}
   _c {{0.5-_a*log(4*_a)}}
  }
push $N44fd1000
  Expression {
   temp_name0 rp
   temp_expr0 pow(r,m_1)
   temp_name1 gp
   temp_expr1 pow(g,m_1)
   temp_name2 bp
   temp_expr2 pow(b,m_1)
   expr0 pow((c_1+c_2*rp)/(1+c_3*rp),m_2)
   expr1 pow((c_1+c_2*gp)/(1+c_3*gp),m_2)
   expr2 pow((c_1+c_2*bp)/(1+c_3*bp),m_2)
   name ST2084_InverseEOTF
   xpos 510
   ypos -58
   addUserKnob {20 CONSTANTS_tab l CONSTANTS}
   addUserKnob {7 m_1}
   m_1 {{2610/4096*(1/4)}}
   addUserKnob {7 m_2}
   m_2 {{2523/4096*128}}
   addUserKnob {7 c_1}
   c_1 {{107/128}}
   addUserKnob {7 c_2}
   c_2 {{2413/128}}
   addUserKnob {7 c_3}
   c_3 {{2392/128}}
  }
push $N44fd1000
  Expression {
   expr0 sign(r)*pow(fabs(r),1/p)
   expr1 sign(g)*pow(fabs(g),1/p)
   expr2 sign(b)*pow(fabs(b),1/p)
   name power
   xpos 400
   ypos -58
   addUserKnob {20 Params_tab l Params}
   addUserKnob {7 p l power R 0.2 2}
   p {{eotf?2+eotf*0.2:1}}
  }
  Switch {
   inputs 3
   which {{eotf-3}}
   name SwitchInverseEOTF
   xpos 400
   ypos 14
  }
  Output {
   name Output
   xpos 400
   ypos 86
  }
 end_group
 Switch {
  inputs 2
  which {{parent.direction}}
  name SwitchDirection
  xpos 180
  ypos -34
 }
 Output {
  name Output
  xpos 180
  ypos 38
 }
end_group
Group {
 name Write_ResolveACES_ODT_LUT12
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 627
 ypos 462
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate B
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec2100
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateB rev008 Rec2100.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N45dcc800
Group {
 name DRT_ZCAM_IzMh_v12_Blink4
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\nBodged XYZ_to_LMS_ZCAM matrix\nMM tonecurve"
 note_font "Bitstream Vera Sans"
 xpos 856
 ypos 393
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 addUserKnob {4 cat_type l "CAT Type" t "the chromatic adaptation transform to use for converting between white points" M {None "XYZ Scaling" Bradford CAT02 Zhai2018 ""}}
 cat_type Zhai2018
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {6 apply_ssts l "apply SSTS" t "toggle the SingleStageToneScale transform" +STARTLINE}
 apply_ssts true
 addUserKnob {41 DRT_ZCAM_v12_Kernel_mmTonescaleMode l mmTonescaleMode T BlinkScript1.DRT_ZCAM_v12_Kernel_mmTonescaleMode}
 addUserKnob {13 ssts_luminance l "SSTS luminance" t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {6 apply_highlight_desat l "apply highlight desat" t "toggle de-saturating the highlights above SSTS mid luminance based on how much the SSTS has compressed them" +STARTLINE}
 apply_highlight_desat true
 addUserKnob {7 desat_highlights l "desat highlights" t "the amount of desaturation applied to the highlights" R 0 5}
 desat_highlights 3.5
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 apply_gamut_compression l "apply gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l primaries t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {6 discount_illuminant l "discount illuminant (Zhai2018 only)" t "disable the degree of adaptation model for the Zhai2018 CAT\nthis is only effective if the limiting primaries do not use a D65 white point" -STARTLINE}
 discount_illuminant true
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.5
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "gamut cusp (0) to SSTS mid (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "the distance from the achromatic axis of the focal point of the compression where 0.0 is at the achromatic axis and 1.0 the distance of the gamut cusp at the given hue but on the opposite side of the achomatic axis" R 0 2}
 focus_distance 0.5
 addUserKnob {26 focus_depth_label l " " -STARTLINE T "achromatic (0) to cusp opposite (1)"}
 addUserKnob {13 compression_params l compression t "the threshold, limit and power parameters for the PowerP compression function\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.2 1.2}
 addUserKnob {26 compression_params_label l " " -STARTLINE T "threshold / limit / power"}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {3 solve_precision l "solve precision" t "the number of iterations used for finding the gamut boundary using the interval bisection method"}
 solve_precision 10
 addUserKnob {3 inverse_solver_iterations l "inverse solver iterations" t "the number of iterations used for finding the original J & M values when applying the inverse gamut compression"}
 inverse_solver_iterations 10
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -294
 }
set N45d3fc00 [stack 0]
 Viewer {
  frame_range 1-16090
  gl_buffer_depth half-float
  name Viewer1
  xpos -638
  ypos -250
 }
push $N45d3fc00
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/ACES_ODT_Candidates/blink/ZCAM_DRT_v012.blink
  recompileCount 291
  ProgramGroup 1
  KernelDescription "2 \"DRT_ZCAM_v12_Kernel\" iterate pixelWise fffa4edb9a297aff0d39c854057b4a543a4c2c5ce2c43bc6e9e86d9f0226d5fa 2 \"src\" Read Point \"dst\" Write Point 42 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"catType\" Int 1 AAAAAA== \"discountIlluminant\" Bool 1 AA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"applySsts\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyHighlightDesat\" Bool 1 AA== \"desatHighlights\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"boundarySolvePrecision\" Int 1 AAAAAA== \"inverseSolverIterations\" Int 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"invert\" Bool 1 AA== \"XYZ_to_LMS_ZCAM\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"zcam_rho\" Float 1 AAAAAA== \"mmTonescaleMode\" Bool 1 AA== \"Lp\" Float 1 AAAAAA== \"su\" Float 1 AAAAAA== \"c0\" Float 1 AAAAAA== \"cs\" Float 1 AAAAAA== \"c1\" Float 1 AAAAAA== \"p\" Float 1 AAAAAA== \"w1\" Float 1 AAAAAA== \"s1\" Float 1 AAAAAA== \"ex\" Float 1 AAAAAA== \"eb\" Float 1 AAAAAA== \"e0\" Float 1 AAAAAA== \"s0\" Float 1 AAAAAA== \"fl\" Float 1 AAAAAA== \"dch\" Float 1 AAAAAA== \"sat\" Float 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== 42 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"catType\" 1 1 \"discountIlluminant\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"applySsts\" 1 1 \"sstsLuminance\" 3 1 \"applyHighlightDesat\" 1 1 \"desatHighlights\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 3 1 \"smoothCusps\" 1 1 \"boundarySolvePrecision\" 1 1 \"inverseSolverIterations\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"invert\" 1 1 \"XYZ_to_LMS_ZCAM\" 9 1 \"zcam_rho\" 1 1 \"mmTonescaleMode\" 1 1 \"Lp\" 1 1 \"su\" 1 1 \"c0\" 1 1 \"cs\" 1 1 \"c1\" 1 1 \"p\" 1 1 \"w1\" 1 1 \"s1\" 1 1 \"ex\" 1 1 \"eb\" 1 1 \"e0\" 1 1 \"s0\" 1 1 \"fl\" 1 1 \"dch\" 1 1 \"sat\" 1 1 \"mmScaleFactor\" 1 1 70 \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA== \"zcam_L_A\" Float 1 1 AAAAAA== \"zcam_F_b\" Float 1 1 AAAAAA== \"zcam_F_L\" Float 1 1 AAAAAA== \"zcam_cb\" Float 1 1 AAAAAA== \"zcam_cg\" Float 1 1 AAAAAA== \"zcam_c1\" Float 1 1 AAAAAA== \"zcam_c2\" Float 1 1 AAAAAA== \"zcam_c3\" Float 1 1 AAAAAA== \"zcam_eta\" Float 1 1 AAAAAA== \"zcam_luminance_shift\" Float 1 1 AAAAAA== \"zcam_viewing_conditions_coeff\" Float 1 1 AAAAAA== \"cat_adaptDegree\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"ssts_min_stop_sdr\" Float 1 1 AAAAAA== \"ssts_max_stop_sdr\" Float 1 1 AAAAAA== \"ssts_min_stop_rrt\" Float 1 1 AAAAAA== \"ssts_max_stop_rrt\" Float 1 1 AAAAAA== \"ssts_min_lum_sdr\" Float 1 1 AAAAAA== \"ssts_max_lum_sdr\" Float 1 1 AAAAAA== \"ssts_min_lum_rrt\" Float 1 1 AAAAAA== \"ssts_max_lum_rrt\" Float 1 1 AAAAAA== \"ssts_n_knots_low\" Int 1 1 AAAAAA== \"ssts_n_knots_high\" Int 1 1 AAAAAA== \"ssts_m1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_minTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_maxTable\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsLow\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_bendsHigh\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_min_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_mid_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_max_pt\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_knotIncLow\" Float 1 1 AAAAAA== \"ssts_knotIncHigh\" Float 1 1 AAAAAA== \"ssts_pctLow\" Float 1 1 AAAAAA== \"ssts_pctHigh\" Float 1 1 AAAAAA== \"ssts_coefsLow\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_coefsHigh\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"ssts_expShift\" Float 1 1 AAAAAA== \"ssts_paramMin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"ssts_paramMax\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_Bradford\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_LMS_CAT02\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LMS_to_Izazbz\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"limitMmax\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"focusDistanceClamped\" Float 1 1 AAAAAA=="
  kernelSource "\nkernel DRT_ZCAM_v12_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    //\n    // ZCAM Paramters\n    //\n\n    // Chomatic Adaptation Transform to Use\n    // 0: None\n    // 1: XYZ Scaling\n    // 2: Bradford\n    // 3: CAT02\n    // 4: Zhai2018 (two-step)\n    int catType;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n\n    //\n    // SSTS Parameters\n    //\n\n    // Toggle SSTS Tone Mapping\n    bool applySsts;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle Highlight De-Saturation\n    bool applyHighlightDesat;\n\n    // Scale the De-Saturation Applied to the Highlights\n    float desatHighlights;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // the distance of the compression focal point\n    // from the achromatic axis\n    // normalised to the distance of the gamut cusp\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / Limit / Power\n    float3 compressionFuncParams;\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    // When solving for the target gamut boundary\n    // how many search interval halving steps to perform\n    int boundarySolvePrecision;\n\n    // Number of iterations to converge on the uncompressed J value \n    // Because of the compression focus point changes depending on the J value of the uncompressed sample\n    // we cannot perfectly invert it since the original J value has now been changed by the forward compression\n    // we can converge on a reasonable approximation of the original J value by iterating the inverse compression\n    // although this is quite an expensive operation\n    int inverseSolverIterations;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n\n    float3x3 XYZ_to_LMS_ZCAM;\n    float zcam_rho;\n\n\n    // Tonescale select\n    bool mmTonescaleMode;\n    // OpenDRT tonescale parameters\n    float Lp;\n    float su;\n    float c0;\n    float cs;\n    float c1;\n    float p;\n    float w1;\n    float s1;\n    float ex;\n    float eb;\n    float e0;\n    float s0;\n    float fl;\n    float dch;\n    float sat;\n    float mmScaleFactor;\n\n  local:\n\n    // constants\n    float HALF_MIN;\n    float HALF_MAX;\n\n    // ZCAM vars\n    float zcam_L_A;\n    float zcam_F_b;\n    float zcam_F_L;\n    float zcam_cb;\n    float zcam_cg;\n    float zcam_c1;\n    float zcam_c2;\n    float zcam_c3;\n    float zcam_eta;\n    // float zcam_rho;\n    float zcam_luminance_shift;\n    float zcam_viewing_conditions_coeff;\n\n    // CAT vars\n    float cat_adaptDegree;\n\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // SSTS constants\n    float ssts_min_stop_sdr;\n    float ssts_max_stop_sdr;\n    float ssts_min_stop_rrt;\n    float ssts_max_stop_rrt;\n    float ssts_min_lum_sdr;\n    float ssts_max_lum_sdr;\n    float ssts_min_lum_rrt;\n    float ssts_max_lum_rrt;\n    int ssts_n_knots_low;\n    int ssts_n_knots_high;\n    float3x3 ssts_m1;\n\n    // SSTS tables\n    // using the float4 type to store the two 2D vectors\n    // because Blink does not support generic array assignments\n    float4 ssts_minTable;\n    float4 ssts_maxTable;\n    float4 ssts_bendsLow;\n    float4 ssts_bendsHigh;\n\n    // SSTS parameters\n    float3 ssts_min_pt;\n    float3 ssts_mid_pt;\n    float3 ssts_max_pt;\n    float ssts_knotIncLow;\n    float ssts_knotIncHigh;\n    float ssts_pctLow;\n    float ssts_pctHigh;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n    float3x3 ssts_coefsLow;\n    float3x3 ssts_coefsHigh;\n\n    float ssts_expShift;\n    float3 ssts_paramMin;\n    float3 ssts_paramMid;\n    float3 ssts_paramMax;\n\n\n    // matrix vars\n    float3x3 identity_matrix;\n    float3x3 XYZ_to_LMS_Bradford;\n    float3x3 XYZ_to_LMS_CAT02;\n    // float3x3 XYZ_to_LMS_ZCAM;\n    float3x3 LMS_to_Izazbz;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 refWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // the maximum colorfulness value of the limiting gamut\n    float limitMmax;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given ZCAM hue (h) value \n    // one must search the table entries for the mathcing entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since tempoary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n\n    // local version of the public focusDistance parameter\n    // this one will be clamped to a value > 0.0\n    float focusDistanceClamped;\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // Two-Stage chromatic adaptation transforms as proposed by  Zhai, Q., & Luo, M. R. (2018)\n  // https://opg.optica.org/oe/fulltext.cfm?uri=oe-26-6-7724\n  // https://github.com/colour-science/colour/blob/e5fa0790adcc3e5df5fa42ddf2bb75214c8cf59c/colour/adaptation/zhai2018.py\n  float3 CAT_Zhai2018( float3 XYZ_b, float3 XYZ_wb, float3 XYZ_wd, float D_b, float D_d, float3x3 M)\n  \{\n    float3 XYZ_wo = 100.0f;\n    float3 RGB_b = vector_dot(M, XYZ_b);\n    float3 RGB_wb = vector_dot(M, XYZ_wb);\n    float3 RGB_wd = vector_dot(M, XYZ_wd);\n    float3 RGB_wo = vector_dot(M, XYZ_wo);\n    \n    float3 D_RGB_b = D_b * (XYZ_wb.y / XYZ_wo.y) * (RGB_wo / RGB_wb) + 1 - D_b;\n    float3 D_RGB_d = D_d * (XYZ_wd.y / XYZ_wo.y) * (RGB_wo / RGB_wd) + 1 - D_d;\n    float3 D_RGB = D_RGB_b / D_RGB_d;\n    \n    float3 RGB_d = D_RGB * RGB_b;\n    float3 XYZ_d = vector_dot(M.invert(), RGB_d);\n    \n    return XYZ_d;\n  \}\n\n  // apply chromatic adaptation transform to 'XYZ' from 'XYZ_ws' to 'XYZ_wd' white points\n  // 'type' selects the cone fundamentals matrix (exept for Zhai2018 which uses a 2-stage tranforms based on CATO2 fundamentals)\n  // 'adaptDegree' sets the degree of adaptation for the Zhai2018 model\n  float3 apply_CAT( float3 XYZ, float3 XYZ_ws, float3 XYZ_wd, int type, float adaptDegree )\n  \{\n    float3x3 XYZ_to_LMS;\n\n    if( type == 1 )\n    \{\n      // XYZ Scaling\n      XYZ_to_LMS = identity_matrix;\n    \}\n    else if( type == 2 )\n    \{\n      // Bradford\n      XYZ_to_LMS = XYZ_to_LMS_Bradford;\n    \}\n    else if( type == 3 )\n    \{\n      // CAT02\n      XYZ_to_LMS = XYZ_to_LMS_CAT02;\n    \}\n    else if( type == 4 )\n    \{\n      // Zhai2018\n      return CAT_Zhai2018(XYZ, XYZ_ws, XYZ_wd, adaptDegree, adaptDegree, XYZ_to_LMS_CAT02);\n    \}\n    else\n    \{\n      // None\n      return XYZ;\n    \}\n\n    float3 LMS_ws = vector_dot(XYZ_to_LMS, XYZ_ws);\n    float3 LMS_wd = vector_dot(XYZ_to_LMS, XYZ_wd);\n\n    // if(LMS_ws.x == 0.0f)\n    // \{\n    //   LMS_ws.x = 0.000001f;\n    // \}\n    // if(LMS_ws.y == 0.0f)\n    // \{\n    //   LMS_ws.y = 0.000001f;\n    // \}\n    // if(LMS_ws.z == 0.0f)\n    // \{\n    //   LMS_ws.z = 0.000001f;\n    // \}\n\n    float3x3 Mscale = identity_matrix;\n    Mscale\[0]\[0] = LMS_wd.x / LMS_ws.x;\n    Mscale\[1]\[1] = LMS_wd.y / LMS_ws.y;\n    Mscale\[2]\[2] = LMS_wd.z / LMS_ws.z;\n\n    float3x3 M = XYZ_to_LMS.invert() * Mscale * XYZ_to_LMS;\n\n    return vector_dot(M, XYZ);\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM intermediate Izazbz colorspace\n  float3 XYZ_to_Izazbz( float3 XYZD65 )\n  \{\n    float3 XYZpD65 = XYZD65;\n    XYZpD65.x = zcam_cb * XYZD65.x - (zcam_cb - 1.0f) * XYZD65.z;\n    XYZpD65.y = zcam_cg * XYZD65.y - (zcam_cg - 1.0f) * XYZD65.x;\n    float3 LMS = vector_dot(XYZ_to_LMS_ZCAM, XYZpD65);\n    float3 LMSp = 0.0f;\n    LMSp.x = spow( ( zcam_c1 + zcam_c2 * spow((LMS.x/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.x/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.y = spow( ( zcam_c1 + zcam_c2 * spow((LMS.y/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.y/10000.0f),zcam_eta) ), zcam_rho);\n    LMSp.z = spow( ( zcam_c1 + zcam_c2 * spow((LMS.z/10000.0f),zcam_eta) ) / ( 1.0f + zcam_c3 * spow((LMS.z/10000.0f),zcam_eta) ), zcam_rho);\n    float3 Izazbz = vector_dot(LMS_to_Izazbz, LMSp);\n    // return float3(LMS_to_Izazbz\[0]\[0], LMS_to_Izazbz\[0]\[1], LMS_to_Izazbz\[0]\[2]);\n    return Izazbz;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to XYZ tristimulus values\n  float3 Izazbz_to_XYZ( float3 Izazbz )\n  \{\n    float3 LMSp = vector_dot(LMS_to_Izazbz.invert(), Izazbz);\n    float3 LMS = 0.0f;\n    LMS.x = 10000.0f*spow((zcam_c1-spow(LMSp.x,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.x,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.y = 10000.0f*spow((zcam_c1-spow(LMSp.y,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.y,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    LMS.z = 10000.0f*spow((zcam_c1-spow(LMSp.z,1.0f/zcam_rho)) / (zcam_c3*spow(LMSp.z,1.0f/zcam_rho)-zcam_c2),1.0f/zcam_eta);\n    float3 XYZpD65 = vector_dot(XYZ_to_LMS_ZCAM.invert(), LMS);\n    float3 XYZD65 = XYZpD65;\n    XYZD65.x = (XYZpD65.x+(zcam_cb-1.0f)*XYZpD65.z)/zcam_cb;\n    XYZD65.y = (XYZpD65.y+(zcam_cg-1.0f)*XYZD65.x)/zcam_cg;\n    return XYZD65;\n  \}\n\n\n  // convert the ZCAM intermediate Izazbz colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 Izazbz_to_JMh( float3 Izazbz, float refWhiteIz, int viewingConditions )\n  \{\n    float3 JMh = 0.0f;\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n\n    JMh.z = fmod(degrees(atan2(Izazbz.z,Izazbz.y))+360.0f,360.0f);\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float Qz  = 2700.0f * spow(Izazbz.x,   (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * zcam_F_s) / pow(zcam_F_b, 0.12f)) * pow(zcam_F_s, 2.2f) * pow(zcam_F_b, 0.5f) * pow(zcam_F_L, 0.2f);\n    JMh.x = 100.0f * (Qz / Qzw);\n    JMh.y = 100.0f * spow((spow(Izazbz.y, 2.0f) + spow(Izazbz.z, 2.0f)), 0.37f) * ((spow(ez, 0.068f) * pow(zcam_F_L, 0.2f)) / (pow(zcam_F_b, 0.1f) * pow(refWhiteIz, 0.78f)));\n\n    return JMh;\n    // return float3(Qz, Qzw, JMh.z);\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to the ZCAM intermediate Izazbz colorspace\n  // needs the Iz values of the reference white and the viewing conditions parameters\n  float3 JMh_to_Izazbz( float3 JMh, float refWhiteIz, int viewingConditions )\n  \{\n    float zcam_F_s = zcam_viewing_conditions_coeff;\n    float Qzm = spow(zcam_F_s, 2.2f) * spow(zcam_F_b, 0.5f) * spow(zcam_F_L, 0.2f);\n    float Qzw = 2700.0f * spow(refWhiteIz, (1.6f * zcam_F_s) / spow(zcam_F_b, 0.12f)) * Qzm;\n    float Izp = spow(zcam_F_b, 0.12f) / (1.6f * zcam_F_s);\n    float Izd = 2700.0f * 100.0f * Qzm;\n    float ez = 1.015f + cos(radians(89.038f+JMh.z));\n    float hzr = radians(JMh.z);\n    float Czp = spow((JMh.y * spow(refWhiteIz, 0.78f) * spow(zcam_F_b, 0.1f)) / (100.0f * spow(ez, 0.068f) * spow(zcam_F_L, 0.2f)), 50.0f / 37.0f);\n\n    return float3( spow((JMh.x * Qzw) / Izd, Izp), Czp * cos(hzr), Czp * sin(hzr));\n  \}\n\n\n  // convert XYZ tristimulus values to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_ZCAM_JMh( float3 XYZ, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return Izazbz_to_JMh(XYZ_to_Izazbz(apply_CAT(XYZ, refWhite, d65White, catType, cat_adaptDegree)), refWhiteIzazbz.x, viewingConditions);\n  \}\n\n\n  // convert the ZCAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 ZCAM_JMh_to_XYZ( float3 JMh, float3 refWhite, float3 d65White, int viewingConditions )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    return apply_CAT(Izazbz_to_XYZ(JMh_to_Izazbz(JMh, refWhiteIzazbz.x, viewingConditions)), d65White, refWhite, catType, cat_adaptDegree);\n  \}\n\n\n  // check if the 3D point 'v' is inside a cube with the dimensions cubeSize x cubeSize x cubeSize \n  // the 'smoothing' parameter rounds off the edges and corners of the cube with the exception of the 0,0,0 and cubeSize x cubeSize x cubeSize corners\n  // a smoothing value of 0.0 applies no smoothing and 1.0 the maximum amount (smoothing values > 1.0 result in undefined behavior )\n  int isInsideCube( float3 v, float cubeSize, float smoothing)\n  \{\n    float3 normv = v / cubeSize;\n\n    float minv = min(normv.x, min(normv.y, normv.z));\n    float maxv = max(normv.x, max(normv.y, normv.z));\n\n    if( smoothing <= 0.0f )\n    \{\n      // when not smoothing we can use a much simpler test\n      if(minv < 0.0f || maxv > 1.0f)\n      \{\n        return 0;\n      \}\n\n      return 1;\n    \}\n\n    float3 clamped = normv;\n\n    float radius = smoothing/2.0f;\n\n    radius = clamp(radius*maxv*(1.0f-minv), 0.0f, radius);\n\n    clamped.x = clamp(normv.x, radius, 1.0f-radius);\n    clamped.y = clamp(normv.y, radius, 1.0f-radius);\n    clamped.z = clamp(normv.z, radius, 1.0f-radius);\n\n\n    if( length(normv - clamped ) > radius)\n    \{\n      return 0;\n    \}\n\n    return 1;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n\n  // convert RGB values in the input colorspace to the ZCAM intermediate Izazbz colorspace\n  float3 input_RGB_to_Izazbz(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAX range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAX, HALF_MAX);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    // assuming 'fully adapted', dark' viewing conditions for input image (does that make sense?)\n    return XYZ_to_Izazbz(apply_CAT(luminanceXYZ, inWhite, d65White, catType, 1.0f));\n    // return apply_CAT(luminanceXYZ, inWhite, d65White, catType, 1.0f);\n  \}\n\n\n  // convert values in the ZCAM intermediate Izazbz colorspace to RGB values in the input colorspace\n  float3 Izazbz_to_input_RGB(float3 Izazbz)\n  \{\n    float3 luminanceXYZ = Izazbz_to_XYZ(Izazbz);\n    luminanceXYZ = apply_CAT(luminanceXYZ, d65White, inWhite, catType, 1.0f);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 RGB = luminanceToEncoding3(encodingIn, luminanceRGB);\n    return RGB;\n  \}\n\n  // convert RGB values in the output colorspace to the ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to ZCAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_ZCAM_JMh(XYZ, refWhite, d65White, viewingConditions);\n    return JMh;\n  \}\n\n\n  // convert ZCAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = ZCAM_JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  // find the JM coordinates of the smoothed boundary of the limiting gamaut in ZCAM at the hue slice 'h' \n  // by searching along the line defined by 'JMSource' and 'JMFocus'\n  // the function will search outwards from where the line intersects the achromatic axis with a staring incement of 'startStepSize'\n  // once the boundary has been crossed it will search in the opposite direction with half the step size\n  // and will repeat this as as many times as is set by the 'precision' paramter\n  float2 findBoundary(float2 JMSource, float2 JMFocus, float h, float3 XYZw, float3 XYZd65, float3x3 XYZ_to_RGB, float smoothing, int precision, float startStepSize )\n  \{\n\n    float2 achromaticIntercept = float2(JMFocus.x - (((JMSource.x-JMFocus.x) / (JMSource.y-JMFocus.y))*JMFocus.y), 0.0f);\n\n    if( achromaticIntercept.x <= 0.0f || achromaticIntercept.x >= limitJmax )\n    \{\n       return achromaticIntercept;\n    \}\n\n\n    float stepSize = startStepSize;\n    float2 unitVector = normalize(achromaticIntercept - JMFocus);\n    float2 JMtest = achromaticIntercept;\n    int searchOutwards = 1;\n\n    for( int i = 0; i < precision; ++i )\n    \{\n\n      while( 1 )\n      \{\n        JMtest = JMtest + unitVector * stepSize;\n        int inside = isInsideCube( vector_dot(XYZ_to_RGB, ZCAM_JMh_to_XYZ( float3(JMtest.x, JMtest.y, h), XYZw, XYZd65, viewingConditions ) / referenceLuminance ), boundaryRGB, smoothing);\n\n        if( searchOutwards )\n        \{\n          if( JMtest.x < 0.0f || JMtest.x > limitJmax || JMtest.y > limitMmax || !inside )\n          \{\n            searchOutwards = 0;\n            stepSize = -fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n        else\n        \{\n          if( JMtest.y < 0.0f || inside )\n          \{\n            searchOutwards = 1;\n            stepSize = fabs(stepSize) / 2.0f;\n            break;\n          \}\n        \}\n      \}\n    \}\n\n\n    float2 JMboundary = float2( clamp(JMtest.x, 0.0f, limitJmax), clamp(JMtest.y, 0.0f, limitMmax) );\n\n    return JMboundary;\n  \}\n\n\n  // apply the forward ACES SingleStageToneScale (SSTS) transfom to the linear 'x' input value and return a luminance value\n  float forwardSSTS(float x, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to HALF_MIN.\n    float logx = log10( max(x, HALF_MIN )); \n\n    float logy;\n\n    if( logx <= log10(minPt.x) )\n    \{ \n        logy = logx * minPt.z + ( log10(minPt.y) - minPt.z * log10(minPt.x) );\n    \}\n    else if(( logx > log10(minPt.x) ) && ( logx < log10(midPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(minPt.x)) / (log10(midPt.x) - log10(minPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsLow\[j/3]\[j%3], ssts_coefsLow\[(j+1)/3]\[(j+1)%3], ssts_coefsLow\[(j+2)/3]\[(j+2)%3]);\n        float3 monomials( t * t, t, 1.0f );\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else if(( logx >= log10(midPt.x) ) && ( logx < log10(maxPt.x) ))\n    \{\n        float knot_coord = 3.0f * (logx-log10(midPt.x)) / (log10(maxPt.x) - log10(midPt.x));\n        int j = knot_coord;\n        float t = knot_coord - float(j);\n        float3 cf(ssts_coefsHigh\[j/3]\[j%3], ssts_coefsHigh\[(j+1)/3]\[(j+1)%3], ssts_coefsHigh\[(j+2)/3]\[(j+2)%3]); \n        float3 monomials(t * t, t, 1.0f);\n        logy = dot(monomials, vector_dot( ssts_m1, cf ));\n    \}\n    else\n    \{\n        logy = logx * maxPt.z + ( log10(maxPt.y) - maxPt.z * log10(maxPt.x) );\n    \}\n\n    return spow(10.0f,logy);\n  \}\n\n\n  float forwardMmTonescale(float x)\n  \{\n      float tc = 0.0f;\n      if (x<0.18)\n      \{\n          tc = cs*spow(x,c0);\n      \}\n      else\n      \{\n          tc = c0*(x-0.18)+0.18;\n      \}\n      \n      float ts = s1*spow((tc/(s0+tc)),p);\n      float tf = ts*ts/(ts+fl);\n      float ccf = spow(s0/(x+s0),dch)*sat;\n\n      return tf;\n  \}\n\n\n\n  float inverseMmTonescale(float x)\n  \{\n\n      float tf = (x+sqrt(x*(4*fl+x)))/2;\n      float ts = s0/(spow((s1/tf),(1/p))-1);\n      float tc = 0.0f;\n      if (ts<0.18)\n      \{\n          tc = spow((ts/cs),(1/c0));\n      \}\n      else\n      \{\n          tc = (ts-0.18)/c0+0.18;\n      \}\n      float ccf = spow(s0/(tc+s0),dch)*sat;\n\n      return tc;\n  \}\n\n\n  \n  // apply the inverse ACES SingleStageToneScale (SSTS) transfomr to the 'x' luminance value and return an linear value\n  float inverseSSTS(float y, float3 minPt, float3 midPt, float3 maxPt)\n  \{\n    float KNOT_INC_LOW  = (log10(midPt.x) - log10(minPt.x)) / 3.0f;\n    float KNOT_INC_HIGH = (log10(maxPt.x) - log10(midPt.x)) / 3.0f;\n\n    // KNOT_Y is luminance of the spline at each knot\n    float KNOT_Y_LOW\[4];\n\n   for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_LOW\[i] = ( ssts_coefsLow\[i/3]\[i%3] + ssts_coefsLow\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float KNOT_Y_HIGH\[ 4];\n\n    for( int i = 0; i < 4; i++ )\n    \{\n      KNOT_Y_HIGH\[i] = ( ssts_coefsHigh\[i/3]\[i%3] + ssts_coefsHigh\[(i+1)/3]\[(i+1)%3]) / 2.0f;\n    \};\n\n    float logy = log10( max(y, 0.0000000001f));\n\n    float logx;\n\n    if( logy <= log10(minPt.y) )\n    \{\n        logx = log10(minPt.x);\n\n    \}\n    else if( (logy > log10(minPt.y)) && (logy <= log10(midPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy > KNOT_Y_LOW\[0] && logy <= KNOT_Y_LOW\[1])\n        \{\n          cf.x = ssts_coefsLow\[0]\[0];\n          cf.y = ssts_coefsLow\[0]\[1];\n          cf.z = ssts_coefsLow\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_LOW\[1] && logy <= KNOT_Y_LOW\[2])\n        \{\n          cf.x = ssts_coefsLow\[0]\[1];\n          cf.y = ssts_coefsLow\[0]\[2];\n          cf.z = ssts_coefsLow\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_LOW\[2] && logy <= KNOT_Y_LOW\[3])\n        \{\n          cf.x = ssts_coefsLow\[0]\[2];\n          cf.y = ssts_coefsLow\[1]\[0];\n          cf.z = ssts_coefsLow\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(minPt.x) + ( t + j) * KNOT_INC_LOW;\n\n    \}\n    else if( (logy > log10(midPt.y)) && (logy < log10(maxPt.y)) )\n    \{\n        int j;\n        float3 cf = 0.0f;\n\n        if( logy >= KNOT_Y_HIGH\[0] && logy <= KNOT_Y_HIGH\[1])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[0];\n          cf.y = ssts_coefsHigh\[0]\[1];\n          cf.z = ssts_coefsHigh\[0]\[2];\n          j = 0;\n        \}\n        else if( logy > KNOT_Y_HIGH\[1] && logy <= KNOT_Y_HIGH\[2])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[1];\n          cf.y = ssts_coefsHigh\[0]\[2];\n          cf.z = ssts_coefsHigh\[1]\[0];\n          j = 1;\n        \}\n        else if( logy > KNOT_Y_HIGH\[2] && logy <= KNOT_Y_HIGH\[3])\n        \{\n          cf.x = ssts_coefsHigh\[0]\[2];\n          cf.y = ssts_coefsHigh\[1]\[0];\n          cf.z = ssts_coefsHigh\[1]\[1];\n          j = 2;\n        \} \n\n        float3 tmp = vector_dot( ssts_m1, cf );\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        float d = sqrt( b * b - 4.0f * a * c);\n\n        float t = ( 2.0f * c) / ( -d - b);\n\n        logx = log10(midPt.x) + ( t + j) * KNOT_INC_HIGH;\n\n    \}\n    else\n    \{\n        logx = log10(maxPt.x);\n\n    \}\n\n    return spow(10.0f, logx);\n  \}\n\n\n  // convert Iz to luminance\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float IzToLuminance( float Iz )\n  \{\n    float V_p = spow(Iz, 1.0f / zcam_rho);\n    float luminance = spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p * zcam_luminance_shift;\n    return luminance;\n  \}\n\n\n  // convert luminance to Iz\n  // note that the PQ fuction used for Iz differs from the ST2084 function by replacing m_2 with rho\n  // it also includes a luminance shift caused by the 2nd row-sum of the XYZ to LMS matrix not adding up to 1.0\n  float luminanceToIz( float luminance )\n  \{\n    float Y_p = spow((luminance/zcam_luminance_shift) / st2084_L_p, st2084_m_1);\n    float Iz = spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), zcam_rho);\n    return Iz;\n  \}\n\n\n  // calculate a scale factor for colorfulness\n  // based on the difference between the original and tone scaled (TS) Iz values\n  // we are only interested in the differences above mid grey\n  // so we first offset the original Iz values to align 18% it with the mid point of the IzTS value\n  float highlightDesatFactor( float Iz, float IzTS )\n  \{\n\n    float linear = IzToLuminance(Iz) / referenceLuminance;\n\n    // no highlight desat below SSTS mid point\n    if( linear < 0.18f )\n    \{\n      return 1.0f;\n    \}\n\n    float IzMid   = luminanceToIz(0.18f * referenceLuminance);\n    float IzMidTS = luminanceToIz(sstsLuminance.y);\n\n    float IzAligned = Iz + IzMidTS - IzMid;\n\n    float desatFactor = 1.0f - clamp( compressPowerP( (log10(max(HALF_MIN, IzAligned)) - log10(max(HALF_MIN, IzTS))) * desatHighlights, compressionFuncParams.x, HALF_MAX, compressionFuncParams.z, 0 ), 0.0f, 1.0f);\n\n    return desatFactor;\n  \}\n\n\n  float3 forwardTonescale( float3 inputIzazbz )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing to do here except converting to JMh\n      return Izazbz_to_JMh(inputIzazbz, refWhiteIzazbz.x, 0);\n    \}\n\n    float linear = IzToLuminance(inputIzazbz.x) / referenceLuminance;\n\n    float luminanceTS = 50.0f;\n\n    // swtich for testing out the MM tonescale from Jed\n    if( mmTonescaleMode )\n    \{\n        luminanceTS = forwardMmTonescale(linear) * mmScaleFactor;\n    \}\n    else \{\n        luminanceTS = forwardSSTS(linear, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    \}\n\n\n    float IzTS = luminanceToIz(luminanceTS);\n\n    float3 outputIzazbz = inputIzazbz;\n\n    if( applySsts )\n    \{\n      outputIzazbz.x = IzTS;\n    \}\n\n    // convert the result to JMh\n    float3 outputJMh = Izazbz_to_JMh(outputIzazbz, refWhiteIzazbz.x, 0);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(inputIzazbz.x, IzTS);\n      outputJMh.y = outputJMh.y * factM;\n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 refWhiteIzazbz = XYZ_to_Izazbz(refWhite*referenceLuminance/refWhite.y);\n    float3 Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n\n    if( ! applySsts && ! applyHighlightDesat )\n    \{\n      // nothing else to do here\n      return Izazbz;\n    \}\n\n    float luminance = IzToLuminance(Izazbz.x);\n\n    // Dummy value to init the var\n    float linear = 50.0f;\n    // swtich for testing out the MM tonescale from Jed\n    if( mmTonescaleMode )\n    \{\n        linear = inverseMmTonescale(luminance/mmScaleFactor);\n    \}\n    else \{\n        linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n    \}\n    \n    \n    float Iz = luminanceToIz(linear*referenceLuminance);\n\n    if( applyHighlightDesat )\n    \{\n      float factM = highlightDesatFactor(Iz, Izazbz.x);\n      JMh.y = JMh.y / factM;\n      Izazbz = JMh_to_Izazbz(JMh, refWhiteIzazbz.x, 0);\n      luminance = IzToLuminance(Izazbz.x);\n      if( mmTonescaleMode )\n      \{\n        linear = inverseMmTonescale(luminance/mmScaleFactor);\n      \}\n      else\n      \{\n        linear = inverseSSTS(luminance, ssts_paramMin, ssts_paramMid, ssts_paramMax);\n      \}\n      Iz = luminanceToIz(linear*referenceLuminance);\n    \}\n\n    if( applySsts )\n    \{\n      Izazbz.x = Iz;\n    \}\n\n    return Izazbz;\n  \}\n\n\n  // compress the ZCAM JM values into the limiting gamut by projecting them towards a focus point beyond the achromatic axis\n  // in order to avoid the gamut compression to also compress black and white tones towards the focus point\n  // (which would result in lifed blacks and crushed highlights)\n  // we offset the focus further away from the achromatic axis the closer the lightness of a sample is to the zero or the limitJmax value\n  // a far away focus point means the compression vector becomes close to orthogonal to the lightness axis preserving black & white lightness\n  // the 'distanceGainCalcJ' paramter should be set to inputJMh.x for the forward direction\n  // and to the best guess of the original, uncompressed values for the inverse direction\n  // this is used for iteratively converging on the original, uncompressed value of J which would have gotten obfuscated by the forward transform\n  float3 compressGamut( float3 inputJMh, int invert, float distanceGainCalcJ )\n  \{\n    if( ! applyGamutCompression )\n    \{\n      return inputJMh;\n    \}\n\n    float sstsMidJ = XYZ_to_ZCAM_JMh( refWhite * sstsLuminance.y, refWhite, d65White, viewingConditions ).x;\n    float2 JMinput = float2(inputJMh.x, inputJMh.y);\n    float2 JMcusp = cuspFromTable( inputJMh.z);\n\n    float focusJ = lerp(JMcusp.x, sstsMidJ, cuspMidBlend);\n\n    float focusDistanceGain = 1.0f;\n\n    if( distanceGainCalcJ > focusJ )\n    \{\n      focusDistanceGain = (limitJmax - focusJ) / max(0.0001f, (limitJmax - min(limitJmax, distanceGainCalcJ)));\n    \}\n    else\n    \{\n      focusDistanceGain = (focusJ) / max(0.0001f, distanceGainCalcJ); \n    \}\n\n    float2 JMfocus = float2( focusJ, -JMcusp.y*focusDistanceClamped*focusDistanceGain );\n    float2 vecToFocus = (JMfocus - JMinput);\n    float2 achromaticIntercept = float2(JMfocus.x - (((JMinput.x-JMfocus.x) / (JMinput.y-JMfocus.y))*JMfocus.y), 0.0f);\n\n    // to reduce the number of expensive boundary finding iterations needed\n    // we taking an educated guess at a good starting step size\n    // based on how far the sample is either above or below the gamut cusp\n    float cuspToTipRatio;\n    if( JMinput.x > JMcusp.x )\n    \{\n      cuspToTipRatio = (JMinput.x - JMcusp.x) / (limitJmax - JMcusp.x);\n    \}\n    else\n    \{\n      cuspToTipRatio = (JMcusp.x - JMinput.x) / (JMcusp.x);\n    \}\n\n    float startStepSize = lerp(JMcusp.y / 3.0f, 0.1f, cuspToTipRatio);\n    float2 JMboundary = findBoundary(JMinput, JMfocus,  inputJMh.z, refWhite, d65White, XYZ_to_RGB_limit, smoothCusps, boundarySolvePrecision, startStepSize);\n    float normFact = 1.0f / max(0.0001f, length(JMboundary - achromaticIntercept));\n    float v = length(JMinput-achromaticIntercept) * normFact;\n    float vCompressed = compressPowerP(v, compressionFuncParams.x, compressionFuncParams.y, compressionFuncParams.z, invert);\n    float2 JMcompressed = 0.0f;\n    // hack to stop nan values after compression\n    if (JMinput.y != 0.0f)\n    \{\n      JMcompressed = achromaticIntercept + normalize(JMinput-achromaticIntercept)*vCompressed/normFact;\n    \}\n    else\n    \{\n      JMcompressed = JMinput;\n    \}\n    return float3(JMcompressed.x, JMcompressed.y, inputJMh.z);\n  \}\n\n\n  // apply the forward gamut compression to the limiting primaries\n  float3 compressGamutForward( float3 JMh )\n  \{\n    float3 JMhcompressed = compressGamut( JMh, 0, JMh.x );\n    // Hack to deal with weird zero values on output\n    // JMhcompressed.x = min(300.0f,JMhcompressed.x);\n    return JMhcompressed;\n  \}\n\n\n  // apply the inverse gamut compression\n  // and iterate a given number of times to reconstruct the original J value\n  float3 compressGamutInverse( float3 JMh )\n  \{\n    float3 JMhuncompressed;\n    float distanceGainCalcJ = JMh.x;\n\n    for( int i = 0; i < inverseSolverIterations; ++i )\n    \{\n      JMhuncompressed = compressGamut( JMh, 1, distanceGainCalcJ );\n      distanceGainCalcJ = JMhuncompressed.x;\n    \}\n\n    return JMhuncompressed;\n  \}\n\n\n  void init()\n  \{\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    zcam_L_A = referenceLuminance * backgroundLuminance / 100.0f;\n    zcam_F_b = sqrt(backgroundLuminance/referenceLuminance);\n    zcam_F_L = 0.171f*spow(zcam_L_A, 1.0f/3.0f) * (1.0f-exp(-48.0f/9.0f*zcam_L_A));\n\n    if( discountIlluminant )\n    \{\n      cat_adaptDegree = 1.0f;\n    \}\n    else\n    \{\n      float viewingConditionsCoeff = 1.0f;\n\n      if( viewingConditions == 0 )\n      \{\n        viewingConditionsCoeff = 0.8f;\n      \}\n      else if( viewingConditions == 1 )\n      \{\n        viewingConditionsCoeff = 0.9f;\n      \}\n      else if( viewingConditions == 2 )\n      \{\n        viewingConditionsCoeff = 1.0f;\n      \}\n\n      cat_adaptDegree = viewingConditionsCoeff * (1.0f - (1.0f / 3.6f) * exp((-zcam_L_A - 42.0f) / 92.0f));\n    \}\n\n    zcam_cb  = 1.15f;\n    zcam_cg  = 0.66f;\n    zcam_c1  = 3424.0f / spow(2.0f,12.0f);\n    zcam_c2  = 2413.0f / spow(2.0f, 7.0f);\n    zcam_c3  = 2392.0f / spow(2.0f, 7.0f);\n    zcam_eta = 2610.0f / spow(2.0f,14.0f);\n    // zcam_rho = 1.7f * 2323.0f / pow(2.0f,5.0f);\n    zcam_luminance_shift = 1.0f / (-0.20151000f + 1.12064900f + 0.05310080f);\n\n    zcam_viewing_conditions_coeff = 1.0f;\n\n    if( viewingConditions == 0 )\n    \{\n      zcam_viewing_conditions_coeff = 0.525f;\n    \}\n    else if( viewingConditions == 1 )\n    \{\n      zcam_viewing_conditions_coeff = 0.59f;\n    \}\n    else if( viewingConditions == 2 )\n    \{\n      zcam_viewing_conditions_coeff = 0.69f;\n    \}\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    ssts_min_stop_sdr =  -6.5f;\n    ssts_max_stop_sdr =   6.5f;\n    ssts_min_stop_rrt = -15.0f;\n    ssts_max_stop_rrt =  18.0f;\n    ssts_min_lum_sdr = 0.02f;\n    ssts_max_lum_sdr = 48.0f;\n    ssts_min_lum_rrt = 0.0001f;\n    ssts_max_lum_rrt = 10000.0f;\n    ssts_n_knots_low = 4;\n    ssts_n_knots_high = 4;\n\n    ssts_minTable = float4(log10(ssts_min_lum_rrt), ssts_min_stop_rrt, log10(ssts_min_lum_sdr), ssts_min_stop_sdr);\n    ssts_maxTable = float4(log10(ssts_max_lum_sdr), ssts_max_stop_sdr, log10(ssts_max_lum_rrt), ssts_max_stop_rrt);\n    ssts_bendsLow = float4(ssts_min_stop_rrt, 0.18f, ssts_min_stop_sdr, 0.35f);\n    ssts_bendsHigh = float4(ssts_max_stop_sdr, 0.89f, ssts_max_stop_rrt, 0.90f);\n\n    float ssts_m1_data\[]=\{ 0.5f,-1.0f, 0.5f,\n                          -1.0f, 1.0f, 0.0f,\n                           0.5f, 0.5f, 0.0f \};\n    ssts_m1.setArray(ssts_m1_data);\n\n    ssts_min_pt.x = 0.18f * spow(2.0f, lerp1D(ssts_minTable, log10(sstsLuminance.x)));\n    ssts_min_pt.y = sstsLuminance.x;\n    ssts_min_pt.z = 0.0f;\n\n    ssts_mid_pt = float3(0.18f, 4.8f, 1.55f);\n\n    ssts_max_pt.x = 0.18f * spow(2.0f, lerp1D(ssts_maxTable, log10(sstsLuminance.z)));\n    ssts_max_pt.y = sstsLuminance.z;\n    ssts_max_pt.z = 0.0f;\n\n    ssts_knotIncLow  = (log10(ssts_mid_pt.x) - log10(ssts_min_pt.x)) / 3.0f;\n    ssts_knotIncHigh = (log10(ssts_max_pt.x) - log10(ssts_mid_pt.x)) / 3.0f;\n    ssts_pctLow  = lerp1D(ssts_bendsLow,  log2(ssts_min_pt.x / 0.18f));\n    ssts_pctHigh = lerp1D(ssts_bendsHigh, log2(ssts_max_pt.x / 0.18f));\n\n    \n    float ssts_coefsLow_data\[] = \{\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      (ssts_min_pt.z * (log10(ssts_min_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_min_pt.y) - ssts_min_pt.z * log10(ssts_min_pt.x)),\n      log10(ssts_min_pt.y) + ssts_pctLow*(log10(ssts_mid_pt.y)-log10(ssts_min_pt.y)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncLow)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    float sssts_coefsHigh_data\[] = \{\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      (ssts_mid_pt.z * (log10(ssts_mid_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_mid_pt.y) - ssts_mid_pt.z * log10(ssts_mid_pt.x)),\n      log10(ssts_mid_pt.y) + ssts_pctHigh*(log10(ssts_max_pt.y)-log10(ssts_mid_pt.y)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)-0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      (ssts_max_pt.z * (log10(ssts_max_pt.x)+0.5f*ssts_knotIncHigh)) + ( log10(ssts_max_pt.y) - ssts_max_pt.z * log10(ssts_max_pt.x)),\n      0.0f, 0.0f, 0.0f \};\n\n    ssts_coefsLow.setArray(ssts_coefsLow_data);\n    ssts_coefsHigh.setArray(sssts_coefsHigh_data);\n\n    ssts_paramMin = ssts_min_pt;\n    ssts_paramMid = ssts_mid_pt;\n    ssts_paramMax = ssts_max_pt;\n    ssts_expShift = log2(inverseSSTS(sstsLuminance.y, ssts_min_pt, ssts_paramMid, ssts_max_pt)) - log2(0.18f);\n    ssts_paramMin.x = spow(2.0f, (log(ssts_paramMin.x) / log(2.0f) - ssts_expShift));\n    ssts_paramMid.x = spow(2.0f, (log(0.18f          ) / log(2.0f) - ssts_expShift));\n    ssts_paramMax.x = spow(2.0f, (log(ssts_paramMax.x) / log(2.0f) - ssts_expShift));\n\n\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n\n    float XYZ_to_LMS_Bradford_data\[]=\{ 0.8951f, 0.2664f,-0.1614f,\n                                      -0.7502f, 1.7135f, 0.0367f,\n                                       0.0389f,-0.0685f, 1.0296f \};\n\n    float XYZ_to_LMS_CAT02_data\[]=\{ 0.7328f, 0.4296f,-0.1624f,\n                                   -0.7036f, 1.6975f, 0.0061f,\n                                    0.0030f, 0.0136f, 0.9834f \};\n\n    float XYZ_to_LMS_ZCAM_data\[]=\{ 0.41478972f, 0.57999900f, 0.01464800f,\n                                  -0.20151000f, 1.12064900f, 0.05310080f,\n                                  -0.01660080f, 0.26480000f, 0.66847990f \};\n\n    float eps = 3.7035226210190005e-11f;\n    float LMS_to_Izazbz_data\[]=\{ 0.000000f, 1.0001f-eps , 0.000000f,\n                                 3.524000f,-4.066708f, 0.542708f,\n                                 0.199076f, 1.096799f,-1.295875f \};\n\n\n    identity_matrix.setArray(identity_matrix_data);\n    XYZ_to_LMS_Bradford.setArray(XYZ_to_LMS_Bradford_data);\n    XYZ_to_LMS_CAT02.setArray(XYZ_to_LMS_CAT02_data);\n    // XYZ_to_LMS_ZCAM.setArray(XYZ_to_LMS_ZCAM_data);\n    LMS_to_Izazbz.setArray(LMS_to_Izazbz_data);\n\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n      \n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n\n    // limitMmax (asumed to coincide with one of the RGBCMY corners of the limitRGB cube)\n    float3 gamutCornersTable\[6];\n    gamutCornersTable\[0] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 0.0f));\n    gamutCornersTable\[1] = limit_RGB_to_JMh(float3(1.0f, 1.0f, 0.0f));\n    gamutCornersTable\[2] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 0.0f));\n    gamutCornersTable\[3] = limit_RGB_to_JMh(float3(0.0f, 1.0f, 1.0f));\n    gamutCornersTable\[4] = limit_RGB_to_JMh(float3(0.0f, 0.0f, 1.0f));\n    gamutCornersTable\[5] = limit_RGB_to_JMh(float3(1.0f, 0.0f, 1.0f));\n\n    limitMmax = 0.0f;\n    for( int i = 0; i < 6; ++i )\n    \{\n      limitMmax = max(limitMmax, gamutCornersTable\[i].y);\n    \}\n\n    // ensure positive, non-zero focus depth\n    // to avoid the gamut boundary search vector becoming zero for achromatic colors\n    // which will cause the boundary search loop to continue forever and the node to hang\n    focusDistanceClamped = max(0.01f, focusDistance);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n\n    if( invert )\n    \{\n      float3 JMh = output_RGB_to_JMh(srcRGB);\n      JMh = compressGamutInverse(JMh);\n      float3 inputIzazbz = inverseTonescale(JMh);\n      dstRGB = Izazbz_to_input_RGB(inputIzazbz);\n    \}\n    else\n    \{\n      float3 inputIzazbz = input_RGB_to_Izazbz(srcRGB);\n      float3 JMh = forwardTonescale(inputIzazbz);\n      JMh = compressGamutForward(JMh);\n      dstRGB = JMh_to_output_RGB(JMh);\n      // diagnostic = Izazbz_to_JMh(inputIzazbz, 0.31334f, 0);\n      diagnostic =  dstRGB;\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_ZCAM_v12_Kernel_encodingIn {{parent.encoding_in}}
  DRT_ZCAM_v12_Kernel_primariesIn {{parent.primaries_in}}
  DRT_ZCAM_v12_Kernel_catType {{parent.cat_type}}
  DRT_ZCAM_v12_Kernel_discountIlluminant {{parent.discount_illuminant}}
  DRT_ZCAM_v12_Kernel_referenceLuminance {{parent.reference_luminance}}
  DRT_ZCAM_v12_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_ZCAM_v12_Kernel_viewingConditions {{parent.viewing_conditions}}
  DRT_ZCAM_v12_Kernel_applySsts {{parent.apply_ssts}}
  DRT_ZCAM_v12_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_ZCAM_v12_Kernel_applyHighlightDesat {{parent.apply_highlight_desat}}
  DRT_ZCAM_v12_Kernel_desatHighlights {{parent.desat_highlights}}
  DRT_ZCAM_v12_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_ZCAM_v12_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_ZCAM_v12_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_ZCAM_v12_Kernel_focusDistance {{parent.focus_distance}}
  DRT_ZCAM_v12_Kernel_compressionFuncParams {{parent.compression_params.x} {parent.compression_params.y} {parent.compression_params.z}}
  DRT_ZCAM_v12_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_ZCAM_v12_Kernel_boundarySolvePrecision {{parent.solve_precision}}
  DRT_ZCAM_v12_Kernel_inverseSolverIterations {{parent.inverse_solver_iterations}}
  DRT_ZCAM_v12_Kernel_encodingOut {{parent.encoding_out}}
  DRT_ZCAM_v12_Kernel_primariesOut {{parent.primaries_out}}
  DRT_ZCAM_v12_Kernel_clampOutput {{parent.clamp_output}}
  DRT_ZCAM_v12_Kernel_invert {{parent.invert}}
  DRT_ZCAM_v12_Kernel_XYZ_to_LMS_ZCAM {
      {{DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler}}
      {{DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler}}
      {{DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler} {DRT_ZCAM_IzMh_v12_Blink4.preMatrix.matrix*matrixScaler}}
    }
  DRT_ZCAM_v12_Kernel_zcam_rho {{"1.7 * 2523.0 / pow(2.0,5.0)"}}
  DRT_ZCAM_v12_Kernel_mmTonescaleMode true
  DRT_ZCAM_v12_Kernel_Lp {{parent.ssts_luminance.z}}
  DRT_ZCAM_v12_Kernel_su 2
  DRT_ZCAM_v12_Kernel_c0 1.2
  DRT_ZCAM_v12_Kernel_cs {{0.18**(1-DRT_ZCAM_v12_Kernel_c0)}}
  DRT_ZCAM_v12_Kernel_c1 1.1
  DRT_ZCAM_v12_Kernel_p {{DRT_ZCAM_v12_Kernel_c1*(0.9+0.05*DRT_ZCAM_v12_Kernel_su)}}
  DRT_ZCAM_v12_Kernel_w1 {{(0.595*DRT_ZCAM_v12_Kernel_Lp/10000)**0.931+1.037}}
  DRT_ZCAM_v12_Kernel_s1 {{DRT_ZCAM_v12_Kernel_w1*DRT_ZCAM_v12_Kernel_Lp/100}}
  DRT_ZCAM_v12_Kernel_ex -0.26
  DRT_ZCAM_v12_Kernel_eb 0.08
  DRT_ZCAM_v12_Kernel_e0 {{2**(DRT_ZCAM_v12_Kernel_ex+DRT_ZCAM_v12_Kernel_eb*log(DRT_ZCAM_v12_Kernel_s1)/log(2))}}
  DRT_ZCAM_v12_Kernel_s0 {{(DRT_ZCAM_v12_Kernel_s1/DRT_ZCAM_v12_Kernel_e0)**(1/DRT_ZCAM_v12_Kernel_c1)}}
  DRT_ZCAM_v12_Kernel_fl 0.01
  DRT_ZCAM_v12_Kernel_dch 0.55
  DRT_ZCAM_v12_Kernel_sat {{max(1,1.125-0.00025*DRT_ZCAM_v12_Kernel_Lp)}}
  DRT_ZCAM_v12_Kernel_mmScaleFactor 100
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -232
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Clamp {
  minimum_enable false
  maximum {{parent.parent.DRT_ZCAM_IzMh_v12_Blink4.ssts_luminance.z/100}}
  name Clamp1
  xpos -908
  ypos -196
 }
 Output {
  name Output1
  xpos -908
  ypos -128
 }
 ColorMatrix {
  inputs 0
  matrix {
      {0.368792 0.531205 0.103642}
      {-0.193458 1.03225 0.131287}
      {-0.0348077 0.283972 0.671427}
    }
  name preMatrix
  xpos -799
  ypos -226
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat2
 label "scale up 7x"
 xpos 856
 ypos 489
}
set N45d3e800 [stack 0]
Group {
 name Write_ResolveACES_ODT_LUT3
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 856
 ypos 547
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate C
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec709
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateC rev008 Rec709.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N45d3e800
Group {
 name SDR_to_HDR
 xpos 976
 ypos 524
}
 Input {
  inputs 0
  name Input1
  xpos 692
  ypos -182
 }
 Colorspace {
  colorspace_in 2.40
  primary_out Rec.2020
  name Colorspace1
  xpos 692
  ypos -142
 }
 Multiply {
  value 100
  name Multiply1
  xpos 692
  ypos -118
 }
 Colorspace {
  colorspace_out st2084
  name Colorspace2
  selected true
  xpos 692
  ypos -86
 }
 Output {
  name Output1
  xpos 692
  ypos 14
 }
end_group
Group {
 name Write_ResolveACES_ODT_LUT6
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 976
 ypos 548
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate C
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (Rec709 sim)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateC rev008 Rec2100 (Rec709 sim).cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N46997200
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat3
 label "scale up 7x"
 xpos 1093
 ypos 499
}
Group {
 name Write_ResolveACES_ODT_LUT8
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos 1093
 ypos 546
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate C
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec2100
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateC rev008 Rec2100.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $N30598800
Group {
 name Write_ResolveACES_ODT_LUT1
 label "\[python nuke.thisNode().knob('file').evaluate().split('/').pop(-1)]"
 xpos -19
 ypos 463
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate A
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec709
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate\[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template.fltransform
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev008/ACES2 CandidateA rev008 Rec709.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
NoOp {
 inputs 0
 name master
 tile_color 0x102307ff
 label "rev\[value revision]"
 note_font_size 50
 note_font_color 0x347216ff
 selected true
 xpos 1174
 ypos -39
 addUserKnob {20 User}
 addUserKnob {1 revision}
 revision 008
 addUserKnob {22 bakeAllODTs T "### This code is embedded in the nukescript, not accessed from here\n\n\n\nimport os\nimport shutil\n\n\n\ndef cubeToCub(cubePath,cubPath):\n    inputCubePath = cubePath\n    ouputCubPath = cubPath\n\n\n\n    # read the cube\n    with open(inputCubePath) as f:\n        lines = f.readlines()\n\n\n\n    # header\n    tlHeader = '''# Truelight Cube v2.1\n    # iDims     3\n    # oDims     3\n    # width     65 65 65\\n\n    # Cube'''\n\n\n\n    # footer\n    tlFooter = '''\\n# end\\n'''\n\n\n\n\n    LUTlines = lines\[2:]\n    LUTlines = \[x.replace('\\n','').split(' ') for x in LUTlines]\n    LUTlines = \[\[float(i) for i in x] for x in LUTlines]\n    LUTlines = \[\[str(i) for i in x] for x in LUTlines]\n\n\n\n    ## remove decimal from 0.0 and 1.0\n    for i, x in enumerate(LUTlines):\n        for j, a in enumerate(x):\n            if '0.0' == a:\n                LUTlines\[i]\[j] = '0'\n            if '1.0' == a:\n                LUTlines\[i]\[j] = '1'\n\n\n\n    # reconstruct the cube string\n    stringLUTlines = \[]\n    for line in LUTlines:\n        stringLUTlines.append(' '.join(line))\n    newLUTStringBlock = '\\n'.join(stringLUTlines)\n\n\n\n    # join it all up\n    outputContents = tlHeader + '\\n' + newLUTStringBlock + '\\n' + tlFooter\n\n\n\n    # check directory for outputCubPath exists, if not, create it\n    if not os.path.exists(os.path.dirname(ouputCubPath)):\n        os.makedirs(os.path.dirname(ouputCubPath))\n\n\n\n    # write the file\n    with open(ouputCubPath, 'w') as f:\n        f.write(outputContents)\n\n\n\ndef bakeCandidateLUTfromNode(node):\n    candidate = node.knob('candidate').value()\n    revision = node.knob('revision').value()\n    target = node.knob('target').value()\n\n\n\n    nukeScriptDir = nuke.script_directory()\n    print(nukeScriptDir)\n    templatePath = os.path.join(nukeScriptDir,node.knob('dctlTemplate').evaluate())\n    fltransformTemplatePath = os.path.join(nukeScriptDir,node.knob('fltransformTemplate').evaluate())\n    flSpacePath = os.path.join(nukeScriptDir,'resources/ACEScct_AP0.flspace')\n    print(flSpacePath)\n\n\n\n    cubePath = os.path.join(nukeScriptDir,node.knob('cubePath').evaluate())\n    ocioCubePath = os.path.join(nukeScriptDir,node.knob('ocioCubePath').evaluate())\n    cubPath = os.path.join(nukeScriptDir,node.knob('cubPath').evaluate())\n    # replace LUT writer path with evaluated path\n    node.knob('file').setValue(cubePath)\n\n\n\n    # check cubePath exists, if not, create it\n    if not os.path.exists(os.path.dirname(cubePath)):\n        os.makedirs(os.path.dirname(cubePath))\n\n\n    # check ocioCubePath exists, if not, create it\n    if not os.path.exists(os.path.dirname(ocioCubePath)):\n        os.makedirs(os.path.dirname(ocioCubePath))\n\n\n\n    dctlPath = cubePath.replace('.cube','.dctl')\n    cubeName = cubePath.split('/').pop(-1)\n\n\n\n    node.knob('generate').execute()\n\n\n\n    ## write the dctl file\n    with open(templatePath) as f:\n        lines = f.readlines()\n    newLines = \[x.replace('replace.cube',cubeName) for x in lines]\n    with open(dctlPath, 'w') as f:\n        f.write(''.join(newLines))\n\n\n\n    # Baselight\n    # convert cube to cub\n    cubeToCub(cubePath,cubPath)\n\n\n    # copy cubePath to ocioCubePath\n    shutil.copy(cubePath,ocioCubePath)\n\n\n\n    ## write the fltransform\n    if target == 'Rec709':\n        fltransformPath = cubPath.replace('.cub','.fltransform')\n        with open(fltransformTemplatePath) as f:\n            lines = f.readlines()\n        newLines = \[x.replace('replaceTransformName','ACES 2.0 Candidate'+ candidate + ' rev'+revision) for x in lines]\n        newLines = \[x.replace('replaceForward_Rec709.cub',os.path.basename(cubPath)) for x in newLines]\n        newLines = \[x.replace('replaceForward_Rec2100.cub',os.path.basename(cubPath).replace('Rec709','Rec2100')) for x in newLines]\n        with open(fltransformPath, 'w') as f:\n            f.write(''.join(newLines))\n\n\n\n    # check ACEScct_AP0.flspace exists, if not, copy it\n    ACEScct_AP0_flspace_path = os.path.dirname(cubPath) + '/ACEScct_AP0.flspace'\n    if not os.path.exists(ACEScct_AP0_flspace_path):\n        shutil.copy(flSpacePath,ACEScct_AP0_flspace_path)\n\n\n\ndef createOCIOconfigs(revision):\n    revision = nuke.thisNode().knob('revision').value()\n    ocioTemplateDir = os.path.join(nukeScriptDir,'resources/')\n    newOcioTemplateDir = os.path.join(nukeScriptDir,'OCIO/')\n    ocioConfigTemplates = \[x for x in os.listdir(ocioTemplateDir) if x.endswith('.ocio')]\n    ocioConfigTemplatePaths = \[os.path.join(ocioTemplateDir,x) for x in ocioConfigTemplates]\n    for config in ocioConfigTemplatePaths:\n        configName = config.split('/').pop(-1)\n        newConfigName = configName.replace('revXXX','rev'+revision)\n        newConfigPath = os.path.join(newOcioTemplateDir,newConfigName)\n        with open(config) as f:\n            lines = f.readlines()\n        newLines = \[x.replace('revXXX','rev'+revision) for x in lines]\n        with open(newConfigPath, 'w') as f:\n            f.write(''.join(newLines))\n\n\nODTWrites = \[]\nfor node in nuke.allNodes():\n    if 'Write_ResolveACES_ODT_LUT' in node.name():\n        ODTWrites.append(node)\n\n\nfor ODTWriteNode in ODTWrites:\n    bakeCandidateLUTfromNode(ODTWriteNode)\n\n\n# createOCIOconfigs(revision)\ncreateOCIOconfigs(nuke.thisNode().knob('revision').getValue())" +STARTLINE}
}
